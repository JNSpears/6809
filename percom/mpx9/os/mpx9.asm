 NAM MPX/9
 TTL PERCOM'S 6809 DISK OPERATING SYSTEM
 SPC 1
**************************************************
* MPX/9 VERSION 1.20                             *
* COPYRIGHT (c) 1980 BY PERCOM DATA CO. INC.     *
* ALL RIGHTS RESERVED                            *
*                                                *
* WRITTEN BY JAMES W. STUTSMAN                   *
*                                                *
* INITIAL RELEASE 05/12/80                       *
*                                                *
* THIS PROGRAM PROVIDES A SIMPLE, BUT POWERFUL   *
* OPERATING SYSTEM FOR THE PERCOM LFD LINE OF    *
* MINIFLOPPY DISK DRIVES.  IT PERMITS DISK FILES *
* TO BE MANIPULATED BY FILE NAMES OF 8 CHAR-     *
* ACTERS OR LESS WITH A TWO CHARACTER SUFFIX.    *
* THE RESIDENT COMMANDS ARE GIVEN BELOW.  EACH   *
* COMMAND CONSISTS OF A SINGLE LETTER FOLLOWED   *
* BY ZERO OR MORE PARAMETERS.  REQUIRED PARAM-   *
* ETERS ARE ENCLOSED WITH "<>", WHILE OPTIONAL   *
* ITEMS ARE ENCLOSED WITH "[]".                  *
*                                                *
*   S(AVE) <NAME> <BEGIN> <END> [EXECUTE]        *
*                     SAVE MEMORY TO DISK FILE   *
*   L(OAD) <NAME> [ADDRESS]                      *
*                     LOAD A FILE INTO MEMORY    *
*   D(ELETE) <NAME>   DELETE FILE FROM DIRECTORY *
*   F(ILES) <DRIVE>   LIST FILES ON TERMINAL     *
*   I(NIT) <DRIVE>    INITIALIZE A DISK          *
*   R(ENAME) <OLD NAME> <NEW NAME>               *
*                     CHANGE THE NAME OF A FILE  *
*   G(O) <ADDRESS>    GO TO MEMORY ADDRESS       *
*   M(ONITOR)         EXIT TO PSYMON MONITOR     *
*                                                *
 IFDEF CURDRIVE
*   C(URRENT) <DRIVE#>                           *
*                     SET CURRENT DRIVE #        *
 ENDC
*                                                *
* IF A COMMAND IS ENTERED WHICH IS NOT FOUND IN  *
* THE ABOVE LIST, MPX/9 WILL SEARCH FOR A FILE   *
* WITH THAT NAME ON DISK.  IF FOUND IT WILL BE   *
* LOADED AND, IF EXECUTION ADDRESS IS PROVIDED,  *
* EXECUTED.                                      *
*                                                *
* BLANKS ARE USED AS DELIMITERS TO SEPARATE THE  *
* ENTRIES ON A LINE.                             *
*                                                *
* WHEN ENTERING FILE NAMES PRECEDE THE NAME      *
* BY THE DRIVE NUMBER TO BE AFFECTED BY THE      *
* COMMAND.  THIS IS ENTERED AS THE NUMBER (1-4)  *
* FOLLOWED BY A SLASH AND THE COMMAND, WITH NO   *
* INTERVENING SPACES.  IN ALL COMMANDS WHICH     *
* REQUIRE A DRIVE NUMBER, 1 IS ASSUMED IF NO     *
* DRIVE NUMBER IS PROVIDED.                      *
*                                                *
* FILE NAMES ARE OF THE FORM 'NAME.SF,SIZE'      *
* WHERE 'NAME' MAY BE UP TO 8 CHARACTERS AND 'SF'*
* MAY 1 OR 2 CHARACTERSE  'SIZE' IS REQUIRED FOR *
* NEW FILES ONLY, AND DEFAULTS TO 8 BLOCKS IF    *
* NOT PROVIDED.  IF NO SUFFIX IS ENTERED FOR A   *
* FILE, CERTAIN DEFAULTS ARE USED.  SEE BELOW    *
*                                                *
* THIS VERSION OF MPX/9 REQUIRES THE PSYMON      *
* ROM MONITOR AND MINIDOS/9 DISK DRIVER.         *
*                                                *
* ERROR CODES DISPLAYED BY MPX/9:                *
*                                                *
*   OK -  0 - NO ERROR                           *
*   FN -  1 - ILLEGAL FUNCTION ATTEMPTED         *
*   ID -  2 - ILLEGAL DISK DRIVE #               *
*   IB -  3 - ILLEGAL BLOCK # USED               *
*   DM -  4 - DISK MISSING OR INOPERATIVE        *
*   NB -  5 - NULL (EMPTY) BLOCK READ            *
*   SK -  6 - SEEK ERROR                         *
*   RD -  7 - DISK READ ERROR                    *
*   VF -  8 - DISK VERIFY ERROR                  *
*   WP -  9 - WRITE PROTECTED DISK               *
*   NF - 10 - FILE NOT FOUND                     *
*   DF - 11 - DISK FULL OR NO SPACE FOR FILE     *
*   IF - 12 - INVALID FILE SPEC                  *
*   NC - 13 - FILE NOT CLOSED                    *
*   UF - 14 - ACCESS TO UNOPENED FILE            *
*   IA - 15 - ILLEGAL ACCESS TO FILE             *
*   EF - 16 - END OF FILE                        *
*   SN - 17 - SYNTAX ERROR IN COMMAND            *
*                                                *
* STANDARD MPX/9 FILE SUFFIXES:                  *
*   CM - COMMAND FILE                            *
*   MI - MEMORY IMAGE FILE                       *
*   SY - SYSTEM FILE                             *
*   TX - TEXT FILE                               *
*   RS - RESERVED SPACE                          *
*   HX - HEXADECIMAL (S1-S9) FILE                *
*                                                *
* DEFAULT SUFFIX ASSUMPTIONS:                    *
*   CM - FOR FILE NAMES ENTERED AS COMMANDS      *
*   MI - FOR FILE NAMES REFERENCED BY 'L' & 'S'  *
*                                                *
* REVISION 1 - JWS 08/28/80                      *
*   BYTE LEVEL I/O FAILS IN LAST BLOCK           *
**************************************************
 SPC 1
**************************************************
* ADDRESS OFFSETS USED BY MPX/9                  *
**************************************************
MPXRAM EQU 256 START OF MPX RAM IN 4K BLOCK
M9RAM EQU 0 MINIDOS/9 RAM OFFSET
PSYRAM EQU $FFDE POINTER TO PSYMON RAM VECTOR
DCBCHN EQU 104 OFFSET TO DCB CHAIN IN ABOVE
FRERAM EQU 126 OFFSET TO FREE RAM POINTER IN ABOVE
K EQU 1024 CONVENIENCE CONSTANT
DIRSIZ EQU 2 NUMBER OF DIRECTORY BLOCKS
MaxDrv  EQU 4   ; Max number of drives supported
 SPC 1EQU  3 ;
**************************************************
* SWI3 PARAMETER DEFINITIONS                     *
**************************************************
* PSYMON (tm) ROUTINE REFERENCES
MONITR EQU 0 RETURN TO MONITOR MODE
REQIO EQU 1 REQUEST I/O
OUTCHR EQU 2 OUTPUT CHARACTER TO TERMINAL
INCHR EQU 3 INPUT CHARACTER FROM TERMINAL
PSTRNG EQU 4 PRINT STRING
GETHEX EQU 5 GET HEX NUMBER
DSPDBY EQU 6 DISPLAY DOUBLE BYTE
DSPSBY EQU 7 DISPLAY SINGLE BYTE
 SPC 1
* MPX/9 ROUTINE REFERENCES
MPX EQU 8 RETURN TO MPX/9
GETLIN EQU 9 GET A LINE OF INPUT
SKPSPC EQU 10 SKIP SPACES IN LINE BUFFER
GETWRD EQU 11 GET THE NEXT WORD IN LINE
PROCMD EQU 12 PROCESS COMMAND LINE
RPTERR EQU 13 REPORT ERROR
LOCFIL EQU 14 LOCATE FILE IN DIRECTORY
LOCSPC EQU 15 LOCATE SPACE IN DIRECTORY
RDDRCT EQU 16 READ DISK DIRECTORY
WTDRCT EQU 17 WRITE DISK DIRECTORY
INTFCB EQU 18 INITIALIZE FCB
OPNFIL EQU 19 OPEN FILE
CLSFIL EQU 20 CLOSE FILE
RDFIL EQU 21 READ A FILE (BYTE)
WTFIL EQU 22 WRITE A FILE (BYTE)
RDBLK EQU 23 READ A BLOCK
WTBLK EQU 24 WRITE A BLOCK
MEMLOD EQU 25 LOAD A MEMORY SEGMENT
MEMSAV EQU 26 SAVE A MEMORY SEGMENT
COMPAR EQU 27 COMPARE STRINGS
BLKMOV EQU 28 BLOCK MOVE
DECNUM EQU 29 GET DECIMAL NUMBER
HEXNUM EQU 30 GET HEXADECIMAL NUMBER
DSPDEC EQU 31 DISPLAY DECIMAL NUMBER & SPACE
DELFIL EQU 32 DELETE A DISK FILE
LOCDCB EQU 33 LOCATE DCB FOR DEVICE
ADDDCB EQU 34 ADD DCB TO DEVICE LIST
DELDCB EQU 35 DELETE DCB FROM DEVICE LIST
GETBAS EQU 36 Get Mpx9 base address.
GETDCB EQU 37 Get System DCB address.
 SPC 1
SYSLIM EQU 37 LAST VALID CALL
 SPC 1
**************************************************
* ASCII CHARACTER CONSTANTS                      *
**************************************************
CR EQU $0D CARRIAGE RETURN
LF EQU $0A LINE FEED
NUL EQU $00 NULL
BS EQU $08 BACKSPACE
CAN EQU $18 CANCEL
SP EQU $20 SPACE
 SPC 1
**************************************************
* MINIDOS/9 DCB DEFINITION                       *
**************************************************
* PART 1 - BASIC DCB DATA
DCBLNK EQU 0 POINTER TO NEXT DCB
DCBDID EQU 2 ASCII ID ('DK' FOR DISK)
DCBDVR EQU 4 DEVICE DRIVER ADDRESS
DCBIOA EQU 6 DEVICE I/O ADDRESS
DCBERR EQU 8 ERROR STATUS CODE
DCBEXT EQU 9 DCB EXTENSION BYTE COUNT
* PART 2 - DEVICE DEPENDENT DATA
DCBDRV EQU 10 DISK DRIVE # (1-4)
DCBBLK EQU 11 DISK BLOCK #
DCBBUF EQU 13 BUFFER ADDRESS
* PART 3 - DRIVER WORK SPACE
DCBTRK EQU 15 TRACK #
DCBSEC EQU 16 SECTOR #
DCBCUR EQU 15 CURRENT TRACK/SECTOR
DCBPRV EQU 17 PREVIOUS BLOCK #
DCBNXT EQU 19 NEXT BLOCK #
DCBCNT EQU 21 BYTE COUNT IN THIS BLOCK
DCBADD EQU 22 DATA ADDRESS FOR THIS BLOCK
DCBTYP EQU 24 BLOCK TYPE CODE
DCBCRC EQU 25 DATA CRC
 SPC 1
DCBSIZ EQU 32 MAXIMUM DCB SIZE
 SPC 1
* FUNCTION CODES
DSKRD EQU 1 READ DISK BLOCK
DSKWT EQU 2 WRITE DISK BLOCK
DSKWV EQU 3 WRITE & VERIFY DISK BLOCK
DSKSL EQU 4 SELECT DISK & RETURN STATUS
DSKCT EQU 8 DISK CONTROL FUNCTION
 SPC 1
**************************************************
* ERROR Codes                                    *
**************************************************
ERR_OK	EQU	 0 ; OK - NO ERROR
ERR_FN	EQU	 1 ; FN - ILLEGAL FUNCTION ATTEMPTED
ERR_ID	EQU	 2 ; ID - ILLEGAL DISK DRIVE #
ERR_IB	EQU	 3 ; IB - ILLEGAL BLOCK # USED
ERR_DM	EQU	 4 ; DM - DISK MISSING OR INOPERATIVE
ERR_NB	EQU	 5 ; NB - NULL (EMPTY) BLOCK READ
ERR_SK	EQU	 6 ; SK - SEEK ERROR
ERR_RD	EQU	 7 ; RD - DISK READ ERROR
ERR_VF	EQU	 8 ; VF - DISK VERIFY ERROR
ERR_WP	EQU	 9 ; WP - WRITE PROTECTED DISK
ERR_NF	EQU	10 ; NF - FILE NOT FOUND
ERR_DF	EQU	11 ; DF - DISK FULL OR NO SPACE FOR FILE
ERR_IF	EQU	12 ; IF - INVALID FILE SPEC
ERR_NC	EQU	13 ; NC - FILE NOT CLOSED
ERR_UF	EQU	14 ; UF - ACCESS TO UNOPENED FILE
ERR_IA	EQU	15 ; IA - ILLEGAL ACCESS TO FILE
ERR_EF	EQU	16 ; EF - END OF FILE
ERR_SN	EQU	17 ; SN - SYNTAX ERROR IN COMMAND

******************************************************
* MINIDOS/9 RAM DEFINITIONS (128 BYTES MAX) @ $f000  *
******************************************************
 ORG M9RAM
 SPC 1
* DRIVE DESCRIPTION TABLE
DDT RMB 32
 SPC 1
* ONE ENTRY PER DRIVE DEFINED AS FOLLOWS:
CURTRK EQU 0 CURRENT TRACK # (HEAD POSITION)
NUMTRK EQU 1 NUMBER OF TRACKS FOR THIS DRIVE
NUMSEC EQU 2 NUMBER OF SECTORS PER TRACK
STEPTM EQU 3 STEP TIME (IN MSEC) FOR THIS DRIVE
SETLTM EQU 4 SETTLE TIME (IN MSEC) FOR THIS DRIVE
SILTBL EQU 5 ADDRESS IN SECTOR INTERLACE TABLE
* ONE BYTE RESERVED FOR EXPANSION
 SPC 1
* MINIDOS DISK DCB
DKDCB RMB DCBSIZ RESERVE SPACE FOR DISK DCB
 SPC 1
SYSVEC RMB 2 SYSTEM CALL VECTOR
 SPC 3
 IFDEF NEWSYSDCB
SYSDCBn RMB 2 ; NUMBER OF SYSDCB'S (DRIVES) IN SYSTEM
SYSDCBv RMB 2*MaxDrv ; POINTER TO DCB FOR EACH DRIVE
 SPC 4
 ENDC
 IFDEF CURDRIVE
CURDRV  RMB 1 ;CURRENT DRIVE, USED WHEN FILE W/O DRIVE IS SPECIFED
 ENDC
 SPC 4
M9RAME  equ *
M9RAMS  equ M9RAME-M9RAM
        if M9RAMS&~$7F
            ERROR M9RAM MUST BE LESS THAN 128 BYTES!
        endc

 SPC 1
**************************************************
* MPX/9 RAM DEFINITIONS                          *
**************************************************
 ORG MPXRAM
 SPC 1
 RMB 256 RESERVED SPACE FOR MPX/9 SYSTEM STACK
STACK EQU *
 SPC 1
* RESERVED SPACE FOR BOOT PROGRAM
BOOT RMB 128 BOOT LIMIT IS 128 BYTES
 SPC 1
* DISK PARAMETERS (CAPACITY & STEP TIME)
DSKPAR RMB 16
 SPC 1
* SYSTEM POINTERS
SYSDCB RMB 2 POINTER TO SYSTEM DISK DCB
MDSBAS RMB 2 MINIDOS/9 RAM BASE ADDRESS
SCLVEC RMB 2 EXTENDED SWI3 CALL VECTOR
DEVLST RMB 2 SYSTEM DEVICE LIST POINTER
MPXLOC RMB 2 MPX/9 DISK LOCATION
 SPC 1
* CONFIGURATION PARAMETERS
SYSBS RMB 1 SYSTEM BACKSPACE CODE
SYSBSE RMB 4 SYSTEM BACKSPACE ECHO STRING
SYSCAN RMB 1 SYSTEM CANCEL CODE
 SPC 1
* SYSTEM FILE CONTROL BLOCK
SYSFCB RMB 32
 SPC 1
* MPX/9 LINE BUFFER
LINBUF RMB 64 SYSTEM LINE BUFFER
 SPC 1
DIRBUF RMB DIRSIZ*256 DIRECTORY BUFFER
 SPC 1
MPXBAS EQU * BASE OF MPX/9 CODE
 SPC 1
**************************************************
* MPX/9 FCB DEFINITION                           *
**************************************************
 ORG 0 RELATIVE TO Y
FCB RMB 32 FILE CONTROL BLOCK
 SPC 1
 ORG FCB FORMAT AFTER INIT OR CLOSE
FCBOPN RMB 1 SET TO 0 BY INIT OR CLOSE
FCBDRN RMB 1 FILE DRIVE #
FCBDBA RMB 2 DISK BUFFER ADDRESS
FCBNAM RMB 8 FILE NAME
FCBSUF RMB 2 FILE SUFFIX
FCBSIZ RMB 2 FILE SIZE
 RMB 15 RESERVED
FCBUFF RMB 1 UNOPENED FILE FLAG (CLEARED BY INIT, CLOSE)
 SPC 1
 ORG FCB FORMAT AFTER OPEN
FCBUSE RMB 1 FILE USAGE (1=R, 2=W, 3=R/W)       0
FCBDRV RMB 1 FILE DRIVE #                       1
FCBBUF RMB 2 BUFFER ADDRESS                     2
FCBCNT RMB 1 CURRENT BYTE COUNT                 4
FCBADD RMB 2 ADDRESS VECTOR                     5
FCBTYP RMB 1 BLOCK TYPE CODE (USER DEFINED)     7
FCBSTR RMB 2 FILE START BLOCK #                 8
FCBEND RMB 2 FILE END BLOCK #                   0a  10
FCBCUR RMB 2 CURRENT RELATIVE BLOCK #           0c  12
FCBPRV RMB 2 PREVIOUS RELATIVE BLOCK #          0e  14
FCBNXT RMB 2 NEXT RELATIVE BLOCK #              10  16
FCBEXT RMB 2 DIRECTORY EXTENSION BYTES          12  18
FCBPTR RMB 2 DATA POINTER                       14  1a
 RMB 9 RESERVED SPACE
FCBSTS RMB 1 FILE STATUS (SET BY OPEN)
 SPC 1
OPNBIT EQU $80 FILE OPEN STATUS BIT
RDBIT EQU $01 READ BUFFER FULL STATUS BIT
WTBIT EQU $02 WRITE BUFFER FULL STATUS BIT
 SPC 1
**************************************************
* MPX/9 DIRECTORY ENTRY DEFINITION               *
**************************************************
 ORG 0 RELATIVE TO X
DIR RMB 16 DIRECTORY ENTRY
 SPC 1
 ORG DIR
DIRNAM RMB 8 FILE NAME
DIRSUF RMB 2 FILE SUFFIX
DIRSTR RMB 2 FILE START BLOCK #
DIREND RMB 2 FILE END BLOCK #
DIREXT RMB 2 EXTENSION BYTES

DumpMem2        EQU     $f826
; PSYMON-ext ROM CODE
	ifdef	RAMTGT
DumpMem2v        EQU     $f053 ; for in @ $F050 RAM ($f000-f3ff)
	ELSE
DumpMem2v        EQU     $F803 ; for in @ $F800 ROM ($f800-ffff)
Line16Dump       EQU     $F805 ; for in @ $F800 ROM ($f800-ffff)

	ENDC


 PAGE
**************************************************
* MPX/9 BOOT ENTRY POINT                         *
**************************************************
 ORG MPXBAS
MPX9EP LEAS STACK,PCR SET STACK
 LDY MDSBAS,PCR POINT Y AT MINIDOS/9 RAM
 LEAX SYSCAL,PCR ESTABLISH SYSTEM CALL VECTOR
 STX SYSVEC,Y
 LEAX SYSCLX,PCR ESTABLISH SYSTEM CALL EXT VECTOR
 STX SCLVEC,PCR
 LDX SYSDCB,PCR POINT X AT DISK DCB
 LDY PSYRAM POINT Y AT PSYMON RAM
 LDD DCBCHN,Y GET PSYMON'S DCB CHAIN
 STD DCBLNK,X ADD DISK DCB TO IT
 STX DEVLST,PCR SAVE DEVICE LIST POINTER
 STX DCBCHN,Y  ; JNS Put back into PSYMON'S DCB CHAIN
 LEAX <MPXBAN,PCR DISPLAY MPX/9 BANNER
 SWI3
 FCB PSTRNG
;JNS+
        LEAX >LDATMSG,PCR       ; print "Loaded @ $" message
        SWI3
        FCB PSTRNG

        LEAX >MPXRAM,PCR        ; print low end of MPX/9 memeory
        tfr X,D
        SWI3
        FCB DSPDBY

        LEAX >LDDOL,PCR       ; print "Loaded @ $" message
        SWI3
        FCB PSTRNG

        LEAX >MPXBAS,PCR        ; print code begining of MPX/9 memeory
        tfr X,D
        SWI3
        FCB DSPDBY

        LEAX >LDATMSG2,PCR      ; print "- " message
        SWI3
        FCB PSTRNG

        LEAX >MPXEND,PCR        ; print high end of MPX/9 memeory
        tfr X,D
        SWI3
        FCB DSPDBY

        LEAX >NEWLIN,PCR        ; print crlf
        SWI3
        FCB PSTRNG

 IFDEF NEWSYSDCB
        LDD     #MaxDrv
        LDX     #$F000+SYSDCBn
        std     ,X++
        ldd     SYSDCB,PCR
        std     ,X++
        std     ,X++
        std     ,X++
        std     ,X++
 ENDC
;JNS-   
        ;JNS LBRA GETCMD EXIT TO COMMAND LOOP ; maybe so bootload could jam a command to be exectued in the buffer?
 IFDEF CURDRIVE
        LDA #1
        STA $f000+CURDRV          ; SET INITIAL DEFAULT DRIVE TO 1
 ENDC
        LBRA MPXRET 
 SPC 1
MPXBAN FCB CR,LF
 FCC 'MPX/9 VERSION 1.20'
 ifdef NEWSYSDCB
        fcc ' (+NEWSYSDCB)'
 endc
 ifdef CURDRIVE
        fcc ' (+CURDRIVE)'
 endc
 FCB CR,LF
 FCC 'COPYRIGHT (c) 1980 BY PERCOM DATA CO. INC.'
NEWLIN FCB CR,LF+$80
;JNS+
LDATMSG FCC 'Loaded @ '
        fcb '$+$80
LDATMSG2 FCC '- '
LDDOL    fcb '$+$80
;JNS-
 SPC 1
**************************************************
* SYSTEM CALL DISPATCHER                         *
**************************************************
SYSCAL CMPA #SYSLIM IS CALL VALID FOR MPX/9?
 BLS SYSCL1 GO IF YES
 JMP [SCLVEC,PCR] EXIT TO NEXT LEVEL ROUTINE
SYSCL1 SUBA #8 CALCULATE OFFSET INTO TABLE
 LSLA
 LEAX <SYSOFF,PCR POINT X AT OFFSET TABLE
 LDD A,X GET OFFSET TO ROUTINE
 LEAX D,X GET ROUTINE ADDRESS ON STACK
 STX 8,S
 PULS CC,A,B,DP,X,Y,PC TURN SWI CALL INTO JSR
 SPC 1
SYSCLX RTI DUMMY ROUTINE
 SPC 1
* SYSTEM CALL OFFSET TABLE
SYSOFF FDB MPXRET-SYSOFF 8 - RETURN TO MPX/9
 FDB GETLN-SYSOFF 9 - GET A LINE OF INPUT
 FDB SKPSP-SYSOFF 10 - SKIP SPACES IN LINE
 FDB GETWD-SYSOFF 11 - GET NEXT WORD IN LINE
 FDB PROCM-SYSOFF 12 - PROCESS COMMAND LINE
 FDB RPTER-SYSOFF 13 - REPORT ERROR
 FDB LOCFL-SYSOFF 14 - LOCATE FILE IN DIRECTORY
 FDB LOCSP-SYSOFF 15 - LOCATE SPACE IN DIRECTORY
 FDB RDDIR-SYSOFF 16 - READ DIRECTORY BLOCK
 FDB WTDIR-SYSOFF 17 - WRITE DIRECTORY BLOCK
 FDB INFCB-SYSOFF 18 - INITIALIZE FCB
 FDB OPNFL-SYSOFF 19 - OPEN FILE
 FDB CLSFL-SYSOFF 20 - CLOSE FILE
 FDB RDFL-SYSOFF 21 - READ FILE
 FDB WTFL-SYSOFF 22 - WRITE FILE
 FDB RDBL-SYSOFF 23 - READ BLOCK
 FDB WTBL-SYSOFF 24 - WRITE BLOCK
 FDB MEMLD-SYSOFF 25 - MEMORY LOAD
 FDB MEMSV-SYSOFF 26 - MEMORY SAVE
 FDB CMPAR-SYSOFF 27 - STRING COMPARE
 FDB BLKMV-SYSOFF 28 - BLOCK MOVE
 FDB DECNM-SYSOFF 29 - GET DECIMAL #
 FDB HEXNM-SYSOFF 30 - GET HEXADECIMAL #
 FDB DSDEC-SYSOFF 31 - DISPLAY DECIMAL #
 FDB DELFL-SYSOFF 32 - DELETE DISK FILE
 FDB LCDCB-SYSOFF 33 - LOCATE DCB FOR DEVICE
 FDB ADDCB-SYSOFF 34 - ADD DCB TO DEVICE LIST
 FDB DLDCB-SYSOFF 35 - DELETE DCB FROM DEVICE LIST
 FDB GTBAS-SYSOFF 36 - Get Mpx9 Base. GETBAS
 FDB GTDCB-SYSOFF 36 - Get System DCB address. GETDCB
 
 SPC 1
**************************************************
* SYSTEM CALL 8 (MPX) - RETURN TO MPX/9          *
**************************************************
MPXRET LEAS STACK,PCR RESET THE STACK
 LDA #CR FORCE RELOAD OF LINE BUFFER
 STA LINBUF,PCR
 SPC 1
**************************************************
* COMMAND LOOP                                   *
**************************************************
GETCMD LEAX LINBUF,PCR POINT X AT LINE BUFFER
 ; LBSR PROCM PROCESS CURRENT COMMAND
 SWI3
 FCB PROCMD
 BEQ GETCM1 GO IF NO ERRORS
 ; LBSR RPTER REPORT THE ERROR
 SWI3
 FCB RPTERR
GETCM1 LEAX <MPXPRM,PCR DISPLAY MPX/9 PROMPT
 SWI3
 FCB PSTRNG
 LEAX LINBUF,PCR POINT X AT LINE BUFFER
 LDB #64 SET SIZE IN B
 ; BSR GETLN FILL THE BUFFER
 SWI3
 FCB GETLIN
 BEQ GETCM1 LOOP IF NO INPUT
 LEAX NEWLIN,PCR DO CR/LF
 SWI3
 FCB PSTRNG
 BRA GETCMD CONTINUE THE LOOP
 SPC 1
MPXPRM FCB CR,LF
 FCC 'MPX'
 FCB '?+$80
 SPC 1
**************************************************
* SYSTEM CALL 9 (GETLIN) - GET INPUT LINE        *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS AT LINE BUFFER   *
*                      B CONTAINS BUFFER LENGTH  *
*                                                *
* EXIT CONDITIONS:  A CONTAINS FIRST CHARACTER,  *
*                     NUL => LINE CANCELED       *
*                     Z FLAG IN CC SET PER A     *
*                   OTHERS UNCHANGED             *
**************************************************
GETLN PSHS B,X,Y SAVE REGISTERS
 CLRB RESET CHARACTER COUNT
GETLN1 SWI3 GET NEXT CHARACTER
 FCB INCHR
 IFDEF CMDREPT
 cmpa #1 repeat last line
 beq GETLN6 go if yes
 ENDC
 CMPA #CR END OF INPUT?
 BEQ GETLN4 GO IF YES
 CMPA SYSBS,PCR BACKSPACE?
 BEQ GETLN2 GO IF YES
 CMPA SYSCAN,PCR LINE CANCEL?
 BEQ GETLN3 GO IF YES
 CMPA #SP CONTROL CODE?
 BLO GETLN1 IGNORE IF YES
 STA ,X+ SAVE THIS CHARACTER
 INCB UPDATE COUNT
 CMPB ,S PAST LIMIT?
 BLO GETLN1 LOOP IF NOT
 LDA SYSBS,PCR OUTPUT A BACKSPACE
 SWI3
 FCB OUTCHR
GETLN2
	IFDEF BS_BUG
	tstb		; fixed bug where BS at first char in line, clears the ? in the prompt.
	bne GETLN2A	; (JNS)
	lda #'?
	swi3
	fcb OUTCHR
	bra GETLN1
GETLN2A:
	ENDC
 TFR X,Y SAVE X REGISTER
 LEAX SYSBSE,PCR ECHO THE BACKSPACE
 SWI3
 FCB PSTRNG
 LEAX ,-Y BACK UP BUFFER POINTER
 DECB UPDATE COUNT
 BPL GETLN1 LOOP IF POSITIVE
GETLN3 CLRA MARK LINE AS CANCELED
 BRA GETLNX
GETLN4 
 STA ,X MARK END OF LINE
	IFDEF CMDREPT
;	leax	1,x	; step over the stored CR
GETLN5	sta	,x+	; clear to end of buffer
	incb
	cmpb	,s
	blo	GETLN5
	ENDC
 LDA [1,S] GET FIRST CHARACTER OF LINE

GETLNX 
 TSTA SET Z FLAG PER A
 PULS B,X,Y,PC RETURN

	IFDEF CMDREPT
GETLN6
	pshs	x
	leax 	SYSBS,PCR ; OUTPUT A BACKSPACE to erase the ^A
	swi3
	fcb 	PSTRNG
	puls	x
GETLN6A
	lda	,x+
	cmpa	#CR
	beq	GETLN1
	tsta
	beq	GETLN1
	incb
	SWI3
	FCB 	OUTCHR
	bra	GETLN6A
	ENDC

 SPC 1
**************************************************
* SYSTEM CALL 11 (GETWRD) - GET NEXT WORD IN LINE*
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO LINE BUFFER   *
*                                                *
* EXIT CONDITIONS:  X POINTS TO WORD             *
*                   Z FLAG IN CC SET IF END OF   *
*                     LINE ENCOUNTERD            *
*                   A CONTAINS FIRST CHARACTER   *
*                     OF WORD FOUND              *
**************************************************
GETWD1 LEAX 1,X MOVE POINTER AHEAD 1
GETWD LDA ,X GET CHARACTER
 CMPA #CR END OF LINE?
 BEQ SKPSPX EXIT IF YES
 CMPA #SP NON-BLANK?
 BNE GETWD1 LOOP IF YES
 SPC 1
**************************************************
* SYSTEM CALL 10 (SKPSPC) - SKIP SPACES IN LINE  *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO LINE BUFFER   *
*                                                *
* EXIT CONDITIONS:  X POINTS TO NON-BLANK        *
*                   Z FLAG IN CC SET IF END OF   *
*                     LINE ENCOUNTERED           *
*                   A CONTAINS NON-BLANK FOUND   *
**************************************************
SKPSP1 LEAX 1,X UPDATE POINTER
SKPSP LDA ,X GET NEXT CHARACTER
 CMPA #CR END OF LINE?
 BEQ SKPSPX GO IF YES
 CMPA #SP BLANK SPACE?
 BEQ SKPSP1 LOOP IF YES
SKPSPX RTS EXIT
 SPC 1
**************************************************
* SYSTEM CALL 12 (PROCMD) - PROCESS COMMAND LINE *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO COMMAND LINE  *
*                                                *
* EXIT CONDITIONS:  EXITS TO SELECTED ROUTINE    *
*                   X POINTS TO PARAMETERS IN    *
*                     COMMAND LINE               *
*                   A,Y,U PRESERVED FOR PARAMS   *
*                   ROUTINE SHOULD RETURN ERROR  *
*                     CODE IN B, 0 IF NO ERROR   *
**************************************************
PROCM PSHS A,X,Y,U,PC SAVE REGISTERS & LEAVE SLOT
 LEAU CMDERR,PCR SET UP ERROR RETURN ON STACK
 STU 7,S
 CLRB PRESET ERROR CODE
 BSR SKPSP GET TO FIRST WORD IN LINE
 lBEQ PROCMX GO IF END OF LINE
 LDA 1,X GET NEXT CHAR IN LINE
 CMPA #SP DELIMITER?
 BEQ RESCMD GO IF YES
 CMPA #CR END OF LINE?
 BNE DSKCMD GO IF NOT
 SPC 1
* CHECK FOR RESIDENT COMMAND
RESCMD LEAY <RESTBL,PCR POINT Y AT RESIDENT TABLE
 LDA ,X COMMAND CHAR TO A
RESCM1 TST ,Y END OF TABLE?
 BEQ DSKCMD GO IF YES
 CMPA ,Y+ FIND COMMAND?
 BEQ RESCM2 GO IF YES
 LEAY 2,Y ADVANCE POINTER
 BRA RESCM1 LOOP
RESCM2 LDD ,Y GET OFFSET TO ROUTINE
 LEAU D,Y PUT ROUTINE ADDRESS ON STACK
 STU 7,S
 BSR GETWD GET THE NEXT WORD IN LINE
 STX 1,S SAVE POINTER
 BRA PROCMX
 SPC 1
* RESIDENT COMMAND TABLE
RESTBL FCB 'S
 FDB SAVE-*
 FCB 'L
 FDB LOAD-*
 FCB 'D
 FDB DELETE-*
 FCB 'F
 FDB FILES-*
 FCB 'I
 FDB INIT-*
 FCB 'R
 FDB RENAME-*
 FCB 'G
 FDB GO-*
 FCB 'M
 FDB MON-*
 IFDEF CURDRIVE
  FCB 'C
  FDB CURRENT-*
 ENDC
 FCB 0 END OF TABLE MARK
 SPC 1
* CHECK FOR DISK RESIDENT COMMAND
DSKCMD:
 LBSR SETFCB INITIALIZE FCB
 BNE PROCMX GO IF ERROR
 STX 1,S SAVE LINE POINTER
 LDD FCBSUF,Y GET FILE SUFFIX
 BNE DSKCM1 GO IF NOT NULL
 LDD #$434D FORCE SUFFIX OF 'CM'
 STD FCBSUF,Y
DSKCM1:
 LBSR LOCFL LOOK UP THE FILE
 BNE PROCMX GO IF ERROR IN LOOKUP
 LDD DIRSTR,X GET STARTING BLOCK #
 LDU DIREXT,X SAVE EXECUTION ADDRESS
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB

 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X ; now x -> count of dcb's
 cmpa   ,x
 bgt    DSKCMERR 
 
 pshs   A
 LDA    FCBDRN,Y GET DRIVE #
 asla
 ldx    a,x
 PULS   A
 ENDC
 
 STD DCBBLK,X PLUG BLOCK #
 LDA FCBDRN,Y GET DRIVE #
 STA DCBDRV,X
 LDD #$FFFF SET ADDRESS TO NULL
 STD DCBBUF,X
 LBSR MEMLD LOAD THE PROGRAM
 BNE PROCMX GO IF ERROR IN LOAD
 CMPU #$FFFF EXECUTION NULL?
 BEQ PROCMX EXIT IF YES
 STU 7,S SET UP EXECUTION ADDRESS
 SPC 1
* EXECUTE THE COMMAND
PROCMX TSTB SET Z FLAG FOR ERROR DETECTION
 PULS A,X,Y,U,PC RESTORE REGISTERS & EXIT
 SPC 1
* DUMMY ROUTINE FOR ERROR RECOVERY
CMDERR RTS GO FROM WHENCE YOU CAME
 SPC 1
 IFDEF NEWSYSDCB
DSKCMERR LDB #ERR_ID ERROR 2 (ID)
 BRA PROCMX
 ENDC
 SPC 1
**************************************************
* SYSTEM CALL 13 (RPTERR) - REPORT ERROR         *
*                                                *
* ENTRY REQUIREMENTS:  B CONTAINS ERROR CODE     *
*                                                *
* EXIT CONDITIONS:  ALL REGISTERS PRESERVED      *
**************************************************
RPTER PSHS CC,A,B,X SAVE REGISTERS USED
 LEAX <ERRHDR,PCR DISPLAY ERROR HEADER
 SWI3
 FCB PSTRNG
 LEAX <ERRTBL,PCR POINT X AT ERROR TABLE
 LDB 2,S GET ERROR CODE
 CMPB #ERRLIM PAST LIMIT?
 BLS RPTER1 GO IF YES
 LDB #ERRLIM FORCE LIMIT
RPTER1 LSLB GET OFFSET INTO TABLE
 ABX POINT TO ERROR MESSAGE
 LDA ,X+ DISPLAY IT
 SWI3
 FCB OUTCHR
 LDA ,X
 SWI3
 FCB OUTCHR
;JNS+
* Add decimal value of error code to message.
 LEAX <ERRMID,PCR DISPLAY TRAILER & EXIT
 SWI3
 FCB PSTRNG
 ; add dec repr of error codes
 clra
 ldb    2,S     ; Get error code
 lbsr DSDEC
;JNS-
 LEAX <ERRTRL,PCR DISPLAY TRAILER & EXIT
 SWI3
 FCB PSTRNG
 PULS CC,A,B,X,PC RESTORE REGISTERS & EXIT
 SPC 1
ERRHDR FCB CR,LF
 FCC '*** MPX/9 ERROR'
 FCB SP+$80
ERRMID FCC ' '
 FCB $28+$80 '(+$80
ERRTRL FCC ') ***'
 FCB CR,LF+$80
 SPC 1
* SYSTEM ERROR TABLE
ERRTBL:
 FCC 'OKFNIDIBDMNBSKRD' ERRORS 0-7
 FCC 'VFWPNFDFIFNCUFIA' ERRORS 8-15
 FCC 'EFSNUE' ERRORS 16-18
 SPC 1
ERRLIM EQU (*-ERRTBL)/2-1
 SPC 1
**************************************************
* SYSTEM CALL 14 (LOCFIL) - LOCATE FILE IN       *
*                           DIRECTORY            *
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR FILE  *
*                        FCB INITIALIZED         *
*                                                *
* EXIT CONDITIONS:  X POINTS TO DIRECTORY ENTRY  *
*                     (UNKNOWN IF ERROR RETURNED)*
*                   B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
**************************************************
LOCFL PSHS A,Y SAVE REGISTERS USED
 LDB #ERR_FN PRESET ERROR 1 (FN)
 TST FCBUFF,Y IS FCB INITIALIZED?
 BNE LOCFL1 GO IF YES
LOCFL1 LDA FCBDRN,Y GET DRIVE #
 LBSR RDDIR READ THE DIRECTORY
 BNE LOCFLX GO IF ERROR
 LEAY FCBNAM,Y POINT Y AT NAME/SUFFIX
LOCFL2 LDD #ERR_NF PRESET ERROR 10 (NF) AND COMPARE LENGTH
 TST ,X END OF DIRECTORY?
 BEQ LOCFLX GO IF YES
 LBSR CMPAR
 BEQ LOCFL4 GO IF MATCHED
 LEAX 16,X ADVANCE TO NEXT ENTRY
 BRA LOCFL2 LOOP BACK
LOCFL4 CLRB RESET ERROR FLAG
LOCFLX TSTB TEST FOR ERRORS
 PULS A,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 15 (LOCSPC) - LOCATE DISK SPACE    *
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR FILE  *
*                                                *
* EXIT CONDITIONS:  X POINTS TO FREE SPACE ENTRY *
*                   B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
**************************************************
LOCSP PSHS A,X,Y SAVE REGISTERS
 LDB #ERR_FN PRESET ERROR CODE (FN)
 TST FCBUFF,Y IS FCB IN INIT STATE?
 LBNE LOCSPX ERROR IF NOT
 LDD FCBSIZ,Y GET THE REQUESTED SIZE
 BNE LOCSP1 GO IF NON-ZERO
 LDD #2*K/256 SET DEFAULT VALUE
 STD FCBSIZ,Y
LOCSP1 LDA FCBDRN,Y READ THE DIRECTORY
 LBSR RDDIR
 LBNE LOCSPX GO IF ERROR
 LDB #DIRSIZ*16-2 SET LIMIT COUNT
LOCSP2 LEAX 16,X ADVANCE POINTER
 TST ,X AT END OF DIRECTORY?
 BEQ LOCSP6 GO IF YES
 PSHS B SAVE COUNTER
 LDD DIRSTR,X GET START BLOCK FOR THIS FILE
 SUBD DIREND-16,X CALC SPACE BETWEEN FILES
 SUBD #1
 CMPD FCBSIZ,Y IS THIS ENOUGH SPACE?
 PULS B RESTORE COUNTER
 BHS LOCSP3 GO IF YES
 DECB LOOP THROUGH DIRECTORY
 BNE LOCSP2
 BRA LOCSP8
LOCSP3 PSHS X SAVE POINTER
 LEAX DIRSIZ*256+DIRBUF,PCR POINT TO LAST ENTRY
LOCSP4 TFR X,Y SET UP FOR PUSHDOWN
 LEAX -16,X
 LDD #16 PUSH DOWN ONE ENTRY
 LBSR BLKMV
 CMPX ,S AT FOUND ENTRY?
 BNE LOCSP4 LOOP IF NOT
LOCSP5 CLR ,X+ CLEAR THE ENTRY
 DECB
 BNE LOCSP5
 PULS X RESTORE POINTERS
 LDY 3,S
 LDD DIREND-16,X GET PRIOR END SECTOR
 ADDD #1 ESTABLISH START
 STD DIRSTR,X
LOCSP6 LDD DIRSTR,X CALC END SECTOR
 ADDD FCBSIZ,Y
 SUBD #1
 STD DIREND,X
 TST 16,X IS THIS LAST FILE?
 BNE LOCSP7
 LDA FCBDRN,Y GET DRIVE # OFFSET
 ASLA
 ASLA
 ASLA
 LDY MDSBAS,PCR POINT Y AT MINIDOS/9 RAM
 LEAY A,Y POINT Y AT DDT ENTRY
 LDA NUMTRK,Y GET NUMBER OF TRACKS
 LDB NUMSEC,Y GET NUMBER OF SECTORS
 MUL CALCULATE LARGEST POSSIBLE BLOCK #
 CMPD DIREND,X IS DISK FULL?
 BLS LOCSP8 GO IF YES
 LDD DIREND,X PLUG START OF FREE SPACE
 ADDD #1
 STD DIRSTR+16,X
LOCSP7 STX 1,S SAVE DIR POINTER
 LDY 3,S POINT Y AT NAME
 LEAY FCBNAM,Y
 EXG X,Y SET FCB AS SOURCE
 LDD #10 MOVE 10 BYTES
 LBSR BLKMV MOVE NAME INTO DIRECTORY
 CLRB RESET ERROR FLAG
 BRA LOCSPX
LOCSP8 LDB #ERR_DF REPORT ERROR (DF)
LOCSPX TSTB TEST ERROR STATUS
 PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 16 (RDDRCT) - READ DISK DIRECTORY  *
*                                                *
* ENTRY REQUIREMENTS:  A CONTAINS DRIVE #        *
*                                                *
* EXIT CONDITIONS:  X POINTS AT DIRECTORY BUFFER *
*                   B CONTAINS ERROR CODE        *
**************************************************
RDDIR PSHS A,Y SAVE REGISTERS
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB
 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	RDDIRERR ERROR	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	RDDIRERR	; IF ZERO THEN ERROR
 ENDC
 LEAY DIRBUF,PCR POINT Y AT DIRECTORY BUFFER
 STA DCBDRV,X SET DRIVE #
 STY DCBBUF,X SET BUFFER ADDRESS
 LDD #1 SET START BLOCK
 STD DCBBLK,X
 LBSR MEMLD LOAD THE DIRECTORY
 BNE RDDIRX GO IF ERROR
 LEAX DIRBUF,PCR POINT TO BUFFER
 CLRB RESET ERROR
RDDIRX PULS A,Y,PC RESTORE REGISTERS & EXIT
 IFDEF NEWSYSDCB
RDDIRERR LDB #ERR_ID ERROR 2 (ID)
 BRA RDDIRX
 ENDC
 SPC 1
**************************************************
* SYSTEM CALL 17 (WTDRCT) - WRITE DISK DIRECTORY *
*                                                *
* ENTRY REQUIREMENTS:  A CONTAINS DRIVE #        *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
**************************************************
WTDIR PSHS A,X,Y SAVE REGISTERS
 LDX SYSDCB,PCR POINT X AT DCB

 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	WTDIRERR ERROR	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	WTDIRERR	; IF ZERO THEN ERROR
 ENDC

 LEAY DIRBUF,PCR POINT Y AT DIRECTORY BUFFER
 STA DCBDRV,X SET DRIVE #
 STY DCBBUF,X SET BUFFER ADDRESS
 LDD #1 SET BLOCK #
 STD DCBBLK,X
 LDD #DIRSIZ*256 SET UP DIRECTORY SIZE

 LBSR MEMSV SAVE THE DIRECTORY
WTDIRX PULS A,X,Y,PC RESTORE & EXIT
 IFDEF NEWSYSDCB
WTDIRERR LDB #ERR_ID ERROR 2 (ID)
 BRA WTDIRX
 ENDC
 SPC 1
**************************************************
* INITIALIZE SYSTEM FCB (INTERNAL USE ONLY)      *
**************************************************
SETFCB LEAY SYSFCB,PCR POINT TO SYSTEM FCB
 SPC 1
**************************************************
* SYSTEM CALL 18 (INTFCB) - INITIALIZE FCB       *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS AT FILSPEC       *
*                      Y POINTS AT FCB           *
*                                                *
* EXIT CONDITIONS:  X POINTS TO NEXT WORD        *
*                   B CONTAINS ERROR CODE        *
*************************************************
INFCB PSHS A,X,Y SAVE REGISTERS
 LDB #32 SET LOOP COUNTER
INFCB1 CLR ,Y+ CLEAR THE FCB TO ZEROES
 DECB
 BNE INFCB1
 LDY 3,S RESTORE FCB POINTER
 LDD #2*K/256
 STD FCBSIZ,Y SET DEFAULT SIZE
 IFDEF CURDRIVE
  LDA $f000+CURDRV SET DEFAULT DRIVE TO CURRENT DRIVE
 ELSE
  LDA #1 SET DEFAULT DRIVE #
 ENDC
 LDB 1,X GET 2ND CHAR OF FILE SPEC
 CMPB #'/ DRIVE # PRESENT?
 BNE INFCB2 GO IF NOT
 LDA ,X++ GET DRIVE # AND SKIP '/'
 LBSR CHKDRV CHECK IT
 BNE INFCBX GO IF ERROR
INFCB2 STA FCBDRN,Y SAVE DRIVE #
 LDB #8 SET NAME LIMIT COUNT
 LEAY FCBNAM,Y POINT Y AT NAME FIELD
INFCB3 BSR CHKCHR GET NEXT CHARACTER
 BEQ INFCB4 GO IF DELIMITER
 CMPA #'. END OF NAME?
 BEQ INFCB4 GO IF YES
 CMPA #', END OF NAME?
 BEQ INFCB4 GO IF YES
 STA ,Y+ SAVE THE CHARACTER
 DECB LOOP THROUGH NAME
 BNE INFCB3
 BSR CHKCHR GET NEXT CHAR
 BEQ INFCB8 GO IF DELIMITER
 LEAY B,Y               advance pointer
 CMPA #', END OF NAME?
 BEQ INFCB6 GO IF YES
 CMPA #'. END OF NAME FIELD?
 BNE INFCB9 ERROR IF NOT
INFCB4 LEAY B,Y ADVANCE POINTER
 CMPB #8 ANY NAME FOUND?
 BEQ INFCB9 ERROR IF NOT
 CMPA #', END OF NAMES?
 BEQ INFCB6 GO IF YES
 CMPA #'. SUFFIX PRESENT?
 BNE INFCB8 GO IF NOT
 LDB #2 SET SUFFIX LIMIT
INFCB5 BSR CHKCHR GET NEXT CHARACTER
 BEQ INFCB8 GO IF DELIMITER
 CMPA #', END OF NAME?
 BEQ INFCB6 GO IF YES
 STA ,Y+ SAVE IT
 DECB LOOP THROUGH SUFFIX
 BNE INFCB5
 BSR CHKCHR GET NEXT CHARACTER
 BEQ INFCB8 GO IF DELIMITER
 CMPA #', END OF SUFFIX?
 BNE INFCB9 ERROR IF NOT
INFCB6 LDY 3,S RESTORE FCB POINTER
 LBSR DECNM GET THE SIZE
 STD FCBSIZ,Y
INFCB8 LEAX -1,X BACK UP POINTER
 LBSR SKPSP SKIP TO NEXT WORD
 STX 1,S SAVE POINTER
 CLRB RESET ERROR STATUS
 LDY 3,S
 LDX FCBSIZ,Y
 BNE INFCBX
INFCB9 LDB #ERR_IF REPORT ERROR 12 (IF)
INFCBX TSTB TEST FOR ERRORS
 PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
* GET NEXT LINE CHAR & CHECK FOR DELIMITER
CHKCHR LDA ,X+ GET A CHARACTER
 CMPA #CR END OF LINE?
 BEQ CHKCHX EXIT IF YES
 CMPA #SP DELIMITER?
CHKCHX RTS
 SPC 1
 
* CONVERT DRIVE # TO BINARY & VALIDATE IT
CHKDRV LDB #ERR_ID PRESET ERROR CODE (ID)
 SUBA #'0 CONVERT ASCII TO BINARY
 BLE CHKDRX GO IF ERROR
 CMPA #MaxDrv IS IT TOO BIG?
 BGT CHKDRX ERROR IF YES
 CLRB RESET ERROR CODE
CHKDRX TSTB SET/RESET Z FLAG
 RTS
 SPC 1
**************************************************
* SYSTEM CALL 19 (OPNFIL) - OPEN FILE            *
*                                                *
* ENTRY REQUIREMENTS:  A CONTAINS USAGE CODE     *
*                      Y POINTS TO FCB           *
*                      X POINTS TO DATA BUFFER   *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
OPNFL PSHS A,X,Y SAVE REGISTERS USED
 LDB #ERR_FN PRESET ERROR CODE (FN)
 STA FCBUSE,Y SET USAGE CODE
 BEQ OPNFLX ERROR IF 0
 CMPA #3 IS IT > 3?
 BHI OPNFLX ERROR IF YES
 LDB #ERR_NC PRESET ERROR (NC)
 TST FCBUFF,Y IS FCB INITIALIZED?
 BNE OPNFLX ERROR IF NOT
 LBSR LOCFL LOOK UP THE FILE
 BEQ OPNFL1 GO IF FOUND
 CMPB #ERR_NF WAS ERROR 'NF'?
 BNE OPNFLX EXIT IF NOT
 LDB FCBUSE,Y CHECK USAGE
 BITB #2 WRITING TO FILE?
 BEQ OPNFLX EXIT IF NOT
 LBSR LOCSP FIND SPACE FOR NEW FILE
 BNE OPNFLX GO IF ERROR
 LDA FCBDRN,Y GET DRIVE #
 LBSR WTDIR REWRITE THE DIRECTORY
 BNE OPNFLX GO IF ERROR
OPNFL1 LDD DIRSTR,X PLUG FILE BOUNDS
 STD FCBSTR,Y
 LDD DIREND,X
 STD FCBEND,Y
 LDD DIREXT,X SAVE EXTENSION BYTES
 STD FCBEXT,Y
 LDD 1,S PLUG BUFFER ADDRESS
 STD FCBBUF,Y
 STD FCBPTR,Y
 STD FCBADD,Y
 CLRA
 CLRB
 STD FCBCNT,Y INITIALIZE FCB
 STD FCBCUR,Y
 STD FCBPRV,Y
 STD FCBNXT,Y
 LDA #OPNBIT MARK FILE OPEN
 STA FCBSTS,Y
 LDA FCBUSE,Y GET FILE USAGE
 CMPA #1 INPUT FILE?
 BNE OPNFL2 GO IF NOT
 LBSR RDBL READ THE FIRST BLOCK
 BNE OPNFLX GO IF ERROR
OPNFL2 CLRB RESET ERROR FLAG
OPNFLX TSTB TEST ERROR STATUS
 PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 20 (CLSFIL) - CLOSE A FILE         *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO OPEN FCB      *
*                                                *
* EXIT CONDITIONS:  X POINTS TO INIT. FCB        *
*                   B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
CLSFL PSHS A,X,Y SAVE REGISTERS
 LBSR OPNCHK CHECK FOR OPEN FILE
 BNE CLSFLX ERROR IF NOT
 LDA #WTBIT SET UP BIT MASK
 BITA FCBSTS,Y IS WRITE REQUIRED?
 BNE CLSFL1 GO IF YES
 CMPA FCBUSE,Y IS FILE A DESTINATION?
 BNE CLSFL3 GO IF NOT
 LDD FCBPRV,Y REREAD PREVIOUS BLOCK
 STD FCBCUR,Y
 INC FCBUSE,Y SET USAGE TO S/D FOR READ
 LBSR RDBL PERFORM THE READ
 BNE CLSFLX GO IF ERROR
 DEC FCBUSE,Y RESET USAGE TO DEST
CLSFL1 LDA FCBUSE,Y CHECK FILE USAGE
 CMPA #WTBIT DESTINATION?
 BNE CLSFL2 GO IF NOT
 CLR FCBNXT,Y MARK END OF FILE
 CLR FCBNXT+1,Y
CLSFL2 LBSR WTBL WRITE THE BLOCK
 BNE CLSFLX GO IF ERROR
CLSFL3 LDA FCBDRV,Y GET DRIVE #
 LBSR RDDIR READ THE DIRECTORY
 BNE CLSFLX GO IF ERROR
 LDA DIRSIZ*16-1 SET ENTRY LIMIT ON STACK
 STA ,-S
 LDD FCBSTR,Y GET START BLOCK #
CLSFL4 CMPD DIRSTR,X FOUND THE FILE?
 BEQ CLSFL5 GO IF YES
 LEAX 16,X ADVANCE THE POINTER
 DEC ,S DECREMENT LIMIT COUNT
 BNE CLSFL4 LOOP IF NOT ZERO
 LDB #ERR_UF REPORT ERROR (UF)
CLSFL5 LEAS 1,S CLEAR STACK
 BNE CLSFLX GO IF FILE NOT FOUND
 LDD FCBEXT,Y UPDATE EXTENSION BYTES
 STD DIREXT,X

; ; JNS
;  LDA #'^
;  SWI3
;  FCB OUTCHR

;        pshs X,Y
;        lbsr   DSCRLF
;        ldd    #16
;        jsr    [DumpMem2v]
;        lbsr   DSCRLF
;        puls Y,X



 LDA FCBDRV,Y GET DRIVE #
 SWI3 REWRITE DIRECTORY
 FCB WTDRCT
 BNE CLSFLX EXIT IF ERROR
 CLR ,Y++ CLEAR FCBUSE, LEAVE DRIVE #
 LDB #30 SET LOOP COUNT
CLSFL6 CLR ,Y+ CLEAR THE FCB
 DECB
 BNE CLSFL6
 LEAY FCBNAM-32,Y POINT TO NAME FIELD
 LDD #10 SET MOVE LIMIT
 LBSR BLKMV MOVE THE NAME TO THE FCB
 CLRB RESET ERROR FLAG
CLSFLX TSTB CHECK FOR ERRORS
 PULS A,X,Y,PC RESTORE REGISTERS & EXIT
 SPC 1
* CHECK FILE STATUS FOR OPEN FILE
OPNCHK LDA FCBSTS,Y GET FILE STATUS
 BMI OPNCH1 GO IF OPEN
 LDB #ERR_UF REPORT ERROR (UF)
 BRA OPNCHX
OPNCH1 CLRB RESET ERROR FLAG
OPNCHX RTS
 SPC 1
**************************************************
* SYSTEM CALL 21 (RDFIL) - READ A FILE           *
*                          (SINGLE BYTE)         *
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR FILE  *
*                                                *
* EXIT CONDITIONS:  A CONTAINS BYTE READ         *
*                   B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
RDFL PSHS X,Y SAVE REGISTERS
 BSR OPNCHK CHECK FOR FILE OPEN
 BNE RDFLX GO IF ERROR
 LDB #ERR_IA PRESET ERROR CODE (IA)
 LDA #1 CHECK USAGE
 CMPA FCBUSE,Y
 BNE RDFLX GO IF ERROR
 LDA #RDBIT SET BIT MASK
 BITA FCBSTS,Y ANYTHING IN BUFFER?
 BNE RDFL1 GO IF YES
 LDB #ERR_EF PRESET ERROR CODE (EF)
 LDX FCBNXT,Y GET THE NEXT BLOCK
 STX FCBCUR,Y
 BEQ RDFLX GO IF END OF FILE
 BSR RDBL
 BNE RDFLX GO IF ERROR
 LDD FCBBUF,Y RESET THE POINTER
 STD FCBPTR,Y
RDFL1 LDX FCBPTR,Y POINT X AT BUFFER
 LDA ,X+ GET THE NEXT BYTE
 STX FCBPTR,Y SAVE THE POINTER
 DEC FCBCNT,Y UPDATE BYTE COUNT
 BNE RDFL2 GO IF NOT END OF BLOCK
 LDB FCBSTS,Y SET BLOCK EMPTY STATUS
 ANDB #$FF-RDBIT
 STB FCBSTS,Y
RDFL2 CLRB RESET ERROR STATUS
RDFLX TSTB TEST ERROR STATUS
 PULS X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 22 (WTFIL) - WRITE TO A FILE       *
*                          (SINGLE BYTE)         *
*                                                *
* ENTRY REQUIREMENTS:  A CONTAINS BYTE TO WRITE  *
*                      Y POINTS TO FCB FOR FILE  *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
WTFL PSHS A,X,Y SAVE REGISTERS
 BSR OPNCHK CHECK FOR OPEN FILE
 BNE WTFLX GO IF NOT
 LDB #ERR_IA PRESET ERROR CODE (IA)
 LDA #2 CHECK FILE USAGE
 CMPA FCBUSE,Y
 BNE WTFLX GO IF ILLEGAL
 LDA FCBSTS,Y SET WRITE STATUS
 ORA #WTBIT
 STA FCBSTS,Y
 LDX FCBPTR,Y POINT X AT BUFFER
 LDA ,S GET THE DATA BYTE
 STA ,X+ PUT IT IN BUFFER
 STX FCBPTR,Y SAVE THE POINTER
 INC FCBCNT,Y UPDATE BYTE COUNT
 BNE WTFL2 GO IF NOT FULL
 LDD FCBCUR,Y SET UP BLOCK LINKAGE
 ADDD #1
 STD FCBNXT,Y
 ADDD FCBSTR,Y CHECK FOR OVERFLOW
 CMPD FCBEND,Y
 BLS WTFL1 GO IF NOT
 CLR FCBNXT,Y FORCE EOF ON THIS BLOCK
 CLR FCBNXT+1,Y
WTFL1 lBSR WTBL WRITE THE BLOCK
 BNE WTFLX GO IF ERROR
 LDD FCBBUF,Y RESET POINTER
 STD FCBPTR,Y
 CLR FCBCNT,Y RESET BLOCK COUNT
 LDD FCBCUR,Y SAVE BACKWARD LINKAGE
 STD FCBPRV,Y
 LDB #ERR_EF PRESET ERROR CODE (EF)
 PSHS B
 LDD FCBNXT,Y UPDATE CURRENT BLOCK #
 STD FCBCUR,Y
 PULS B
 BEQ WTFLX GO IF EOF
WTFL2 CLRB RESET ERROR CODE
WTFLX TSTB TEST ERROR STATUS
 PULS A,X,Y,PC RESTORE REGISTERS & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 23 (RDBLK) - READ RANDOM FILE BLOCK*
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR READ  *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
RDBL PSHS A,X,Y SAVE REGISTERS
 LBSR OPNCHK CHECK FOR OPEN FILE
 BNE RDBLX GO IF NOT
 LDB #ERR_IA PRESET ERROR CODE (IA)
 LDA #RDBIT CHECK FOR LEGAL USAGE
 BITA FCBUSE,Y
 BEQ RDBLX GO IF ERROR
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB
 LDA FCBDRV,Y PLUG DRIVE #

 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	RDBLERR 	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	RDBLERR		; IF ZERO THEN ERROR
 ENDC
 
 STA DCBDRV,X
 LDB #ERR_EF PRESET ERROR CODE (EF)
 PSHS B
 LDD FCBCUR,Y PLUG BLOCK #
 ADDD FCBSTR,Y
 STD DCBBLK,X
 CMPD FCBEND,Y READ PAST END OF FILE?
 PULS B
 BHI RDBLX ERROR IF YES
 LDD FCBBUF,Y PLUG BUFFER ADDRESS
 STD DCBBUF,X
 LDB #DSKRD READ THE BLOCK
 SWI3
 FCB REQIO

       ; ;JNS
       ; pshs   D,Y,X
       ; LDA    #'r
       ; TFR    X,Y 
       ; LBSR   DspDCB
       ; puls   X,Y,D

 LDB DCBERR,X CHECK FOR ERRORS
 BNE RDBLX
 LDD DCBPRV,X SAVE LINKAGE DATA
 BEQ RDBL1
 SUBD FCBSTR,Y
RDBL1 STD FCBPRV,Y
 LDD DCBNXT,X
 BEQ RDBL2
 SUBD FCBSTR,Y
RDBL2 STD FCBNXT,Y
 LDD DCBCNT,X SAVE CNT, TYP, & ADD
 STD FCBCNT,Y
 LDD DCBADD+1,X
 STD FCBADD+1,Y
 LDA FCBSTS,Y SET BLOCK FULL FLAG
 ORA #RDBIT
 STA FCBSTS,Y
 CLRB RESET ERROR STATUS
RDBLX TSTB CHECK FOR ERRORS
 PULS A,X,Y,PC RESTORE & EXIT 
 IFDEF NEWSYSDCB
RDBLERR LDB #ERR_ID ERROR 2 (ID)
 BRA RDBLX
 ENDC
 SPC 1
**************************************************
* SYSTEM CALL 24 (WTBLK) - WRITE A BLOCK TO A    *
*                          FILE                  *
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR FILE  *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
WTBL PSHS A,X,Y SAVE REGISTERS
 LBSR OPNCHK CHECK FOR OPEN FILE
 BNE WTBLX GO IF NOT
 LDB #ERR_IA PRESET ERROR CODE (IA)
 LDA #2 CHECK FOR LEGAL USAGE
 BITA FCBUSE,Y
 BEQ WTBLX GO IF NOT
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB
 LDA FCBDRV,Y PLUG DRIVE #

 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	WRBLERR 	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	WRBLERR		; IF ZERO THEN ERROR
 ENDC

 STA DCBDRV,X
 LDD FCBBUF,Y PLUG BUFFER ADDRESS
 STD DCBBUF,X
 LDB #ERR_EF PRESET ERROR CODE (EF)
 PSHS B

 LDD FCBCUR,Y GET BLOCK #
 ADDD FCBSTR,Y
 STD DCBBLK,X
 CMPD FCBEND,Y
 PULS B
 BHI WTBLX GO IF PAST END OF FILE

 LDD FCBPRV,Y PLUG LINKAGE VECTORS
 IFDEF WTBL_BUG
       ; WTBL_BUG, writeing block 1 in a file wants a back link to block 0.
       ; this will not work, the back link in block 1 will be 0 (begining of file)
       ; instead of a link to the start block (block 0)
       BEQ WTBL1
 ELSE
       ; if prev is 0 and curr is 0 then take branch to WTBL1. 
       ; if prev is not 0 or curr is not 0 then don't take branch to WTBL1. 
       BNE WTBL0     ; D = FCBPRV,Y != 0
       LDD FCBCUR,Y  ; GET BLOCK #
       BNE WTBL00    ; D = FCBCUR,Y != 0
       BRA WTBL1     ; D == 0 
WTBL00:
       LDD FCBPRV,Y
WTBL0:
 ENDC
 ADDD FCBSTR,Y
WTBL1 STD DCBPRV,X


 LDD FCBNXT,Y
 BEQ WTBL2
 ADDD FCBSTR,Y
WTBL2 STD DCBNXT,X

 LDD FCBCNT,Y PLUG CNT, TYP, & ADD
 STD DCBCNT,X
 LDD FCBADD+1,Y
 STD DCBADD+1,X
 LDB #DSKWV WRITE THE BLOCK

       ; ;JNS
       ; pshs   D,Y,X
       ; LDA    #'w
       ; TFR    X,Y 
       ; LBSR   DspDCB
       ; puls   X,Y,D

 SWI3
 FCB REQIO
 LDB DCBERR,X CHECK ERROR STATUS
 BNE WTBLX
 LDA FCBSTS,Y TURN OFF BLOCK FULL FLAG
 ANDA #$FF-WTBIT
 STA FCBSTS,Y
 CLRB RESET ERROR FLAG
WTBLX TSTB CHECK ERROR STATUS
 PULS A,X,Y,PC RESTORE & EXIT
 IFDEF NEWSYSDCB
WRBLERR LDB #ERR_ID ERROR 2 (ID)
 BRA WTBLX
 ENDC
 SPC 1
**************************************************
* SYSTEM CALL 25 (MEMLOD) - LOAD A MEMORY SEGMENT*
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO DCB FOR LOAD  *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS UNCHANGED             *
**************************************************
MEMLD PSHS A,X SAVE REGISTERS
MEMLD1 LDB #DSKRD READ A BLOCK

         ; pshs   d,x
         ; ldd    #$20   ; SET SIZE IN B 
         ; JSR    [DumpMem2v]     ; dump buffer DCB data.
         ; puls   x,d

 SWI3
 FCB REQIO
 LDB DCBERR,X CHECK ERROR STATUS
 BNE MEMLDX EXIT IF ERROR
 LDD DCBBUF,X GET BUFFER ADDRESS
 CMPD #$FFFF USING DISK ADDRESSES?
 BEQ MEMLD3 GO IF YES
 CLRA SET UP FOR ADD
 LDB DCBCNT,X
 BNE MEMLD2
 INCA
MEMLD2 ADDD DCBBUF,X CALC NEXT DATA ADDRESS
 STD DCBBUF,X
MEMLD3 LDD DCBNXT,X GET FORWARD LINK
 STD DCBBLK,X
 BNE MEMLD1 LOOP IF NOT END OF SEGMENT
MEMLDX TSTB CHECK ERROR FLAG
 PULS A,X,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 26 (MEMSAV) - SAVE A MEMORY SEGMENT*
*                                                *
* ENTRY REQUIREMENTS:  D CONTAINS LENGTH OF SEG. *
*                      X POINTS TO DCB FOR SAVE  *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   A CONTAINS # BLOCKS WRITTEN  *
*                   OTHERS UNCHANGED             *
**************************************************
MEMSV PSHS A,X,Y SAVE REGISTERS
 TSTB IS LENGTH 0 MOD 256?
 BEQ MEMSV1 GO IF YES
 INC ,S
MEMSV1 CLR DCBPRV,X INITIALIZE DCB
 CLR DCBPRV+1,X
 CLR DCBCNT,X
MEMSV2 CMPD #256 SINGLE BLOCK SEGMENT?
 BLS MEMSV3 GO IF YES
 TFR D,Y SAVE SEGMENT LENGTH IN Y
 LDD DCBBUF,X PLUG ADDRESS
 STD DCBADD,X
 LDD DCBBLK,X SET FORWARD LINK
 ADDD #1
 STD DCBNXT,X
 LDB #DSKWV WRITE THE BLOCK
 SWI3
 FCB REQIO
 LDB DCBERR,X GET ERROR CODE
 BNE MEMSVX GO IF ERROR
 LDD DCBBLK,X SAVE BACKWARD LINK
 STD DCBPRV,X
 LDD DCBNXT,X UPDATE CURRENT BLOCK #
 STD DCBBLK,X
 INC DCBBUF,X UPDATE ADDRESS
 TFR Y,D DECREMENT FULL BLOCK COUNTER
 DECA
 BNE MEMSV2 LOOP IF NOT DONE
MEMSV3 STB DCBCNT,X SAVE FINAL BLOCK LENGTH
 LDD DCBBUF,X PLUG ADDRESS
 STD DCBADD,X
 CLR DCBNXT,X KILL FORWARD LINK
 CLR DCBNXT+1,X
 LDB #DSKWV WRITE LAST BLOCK
 SWI3
 FCB REQIO
 LDB DCBERR,X
MEMSVX PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 27 (COMPAR) - STRING COMPARE       *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO STRING 1      *
*                      Y POINTS TO STRING 2      *
*                      D CONTAINS LENGTH         *
*                                                *
* EXIT CONDITIONS:  CC SET PER COMPARE OF 1 TO 2 *
*                   ALL OTHERS PRESERVED         *
**************************************************
CMPAR PSHS D,X,Y SAVE REGISTERS
 CMPD #256 LESS THAN 1 PAGE?
 BLS CMPAR2 GO IF YES
 TSTB IS LENGTH 0 MOD 256?
 BNE CMPAR1 GO IF NOT
 DECA COMPARE 1 LESS PAGE
CMPAR1 PSHS D SAVE COUNTER
 CLRB COMPARE 256 BYTES
 BSR CMPSTR
 PULS D
 BNE CMPARX EXIT IF INEQUALITY
 DECA LOOP THROUGH PAGES
 BNE CMPAR1
CMPAR2 BSR CMPSTR COMPARE LAST BYTES
CMPARX PULS D,X,Y,PC RESTORE & EXIT
 SPC 1
* COMPARE TWO STRINGS FOR LENGTH IN B
CMPSTR LDA ,X+ GET BYTE FROM '1'
 CMPA ,Y+ COMPARE TO BYTE IN '2'
 BNE CMPSTX EXIT IF UNEQUAL
 DECB LOOP THROUGH STRING
 BNE CMPSTR
CMPSTX RTS
 SPC 1
**************************************************
* SYSTEM CALL 28 (BLKMOV) - BLOCK MOVE           *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO SOURCE FIELD  *
*                      Y POINTS TO DEST. FIELD   *
*                      D CONTAINS LENGTH         *
*                                                *
* EXIT CONDITIONS:  CC REGISTER CHANGED          *
*                   OTHERS PRESERVED             *
**************************************************
BLKMV PSHS D,X,Y SAVE REGISTERS
 CMPD #256 LESS THAN 1 PAGE TO MOVE?
 BLS BLKMV2 GO IF YES
 TSTB IS LENGTH 0 MOD 256?
 BNE BLKMV1 GO IF NOT
 DECA ADJUST PAGE COUNTER
BLKMV1 PSHS D SAVE COUNTERS
 CLRB MOVE 256 BYTES
 BSR MOVSTR
 PULS D
 DECA LOOP THROUGH PAGES
 BNE BLKMV1
BLKMV2 BSR MOVSTR MOVE LAST STRING
 PULS D,X,Y,PC RESTORE & EXIT
 SPC 1
* MOVE STRING 1 (X) TO STRING 2 (Y)
MOVSTR LDA ,X+ MOVE A BYTE
 STA ,Y+
 DECB LOOP THROUGH B
 BNE MOVSTR
 RTS
 SPC 1
**************************************************
* SYSTEM CALL 29 (DECNUM) - GET A DECIMAL NUMBER *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO LINE AT #     *
*                                                *
* EXIT CONDITIONS:  D CONTAINS BINARY NUMBER     *
*                   X POINTS TO NEXT WORD        *
*                   CC ALTERED                   *
*                   OTHERS PRESERVED             *
**************************************************
DECNM CLR ,-S INIT RESULT FIELD
 CLR ,-S
DECNM1 LDA ,X+ GET NEXT CHAR
 SUBA #$30 REMOVE BIAS
 BMI DECNM2 GO IF NON-DIGIT
 CMPA #9
 BGT DECNM2
 STA ,-S SET DIGIT IN 16 BIT FIELD
 CLR ,-S
 LDD 2,S MULTIPLY OLD RESULT BY 10
 ADDD 2,S D=D*2
 STD 2,S
 ADDD 2,S D=D*4
 ADDD 2,S D=D*6
 ADDD 2,S D=D*8
 ADDD 2,S D=D*10
 ADDD ,S++ ADD NEW DIGIT
 STD ,S SAVE RESULT
 BRA DECNM1 LOOP FOR MORE
DECNM2 LDA ,-X GET TERMINAL CHARACTER
 PSHS A
 LBSR SKPSP SKIP TO NEXT WORD
 PULS A
 CMPA #SP DELIMITER FOUND?
 BEQ DECNMX EXIT IF YES
 CMPA #CR END OF LINE?
DECNMX PULS D,PC EXIT WITH RESULT
 SPC 1
**************************************************
* SYSTEM CALL 30 (HEXNUM) - GET A HEXADECIMAL    *
*                           NUMBER               *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO LINE AT #     *
*                                                *
* EXIT CONDITIONS:  D CONTAINS BINARY #          *
*                   X POINTS TO NEXT WORD        *
*                   Z FLAG IN CC SET IF NO       *
*                     ERROR IN NUMBER            *
**************************************************
HEXNM CLR ,-S CLEAR RESULT WORK AREA
 CLR ,-S
HEXNM1 LDA ,X+ GET NEXT DIGIT
 SUBA #'0 REMOVE ASCII BIAS
 BMI DECNM2 GO IF NON-DIGIT
 CMPA #9 BIGGER THAN 9?
 BLE HEXNM2 GO IF NOT
 SUBA #7 REMOVE LETTER BIAS
 CMPA #10 LESS THAN 10?
 BLT DECNM2 EXIT IF YES
 CMPA #15 BIGGER THAN 15?
 BGT DECNM2 EXIT IF YES
HEXNM2 PSHS A SAVE THE DIGIT
 LDD 1,S GET PRIOR RESULT
 ASLB SHIFT LEFT 4 BITS
 ROLA
 ASLB
 ROLA
 ASLB
 ROLA
 ASLB
 ROLA
 ADDB ,S+ ADD IN NEW DIGIT
 STD ,S SAVE RESULT
 BRA HEXNM1 LOOP FOR MORE
 SPC 1
**************************************************
* SYSTEM CALL 31 (DSPDEC) - DISPLAY DECIMAL      *
*                           NUMBER               *
*                                                *
* ENTRY REQUIREMENTS:  D CONTAINS BINARY NUMBER  *
*                                                *
* EXIT CONDITIONS:  NUMBER PRINTED AS 5 DIGITS   *
*                   ALL REGISTERS PRESERVED      *
*                     EXCEPT CC                  *
**************************************************
DSDEC PSHS D,X SAVE REGISTERS
 LEAX <CNVTBL,PCR POINT X AT TABLE
 PSHS D PUT WORKING NUMBER ON STACK
 LDA #4 SET LEADING ZERO COUNT
 STA ,-S
DSDEC1 CLR ,-S INIT DIGIT RESULT
 LDD 2,S GET WORKING NUMBER
DSDEC2 INC ,S ADD TO DIGIT COUNTER
 SUBD ,X SUBTRACT TABLE VALUE
 BPL DSDEC2 LOOP UNTIL NEGATIVE
 DEC ,S CORRECT RESULTS
 ADDD ,X
 STD 2,S SAVE WORKING VALUE
 PULS A GET DIGIT COUNT
 ADDA #$30 CONVERT TO ASCII
 TST ,S LEADING ZEROES?
 BEQ DSDEC4 GO IF NOT
 CMPA #$30 IS THIS A ZERO?
 BNE DSDEC3 GO IF NOT
 LDA #SP BLANK IT OUT
 DEC ,S UPDATE ZERO COUNT
 BRA DSDEC4
DSDEC3 CLR ,S RESET LEADING ZERO FLAG
DSDEC4 SWI3 DISPLAY THE DIGIT
 FCB OUTCHR
 LDD ,X++ CHECK FOR END OF TABLE
 CMPD <CNVTBL+8,PCR GOT LAST ENTRY?
 BNE DSDEC1 LOOP IF NOT
 LDA #SP OUTPUT A SPACE
 SWI3
 FCB OUTCHR
 LEAS 3,S CLEAN UP THE STACK
 PULS D,X,PC RESTORE & EXIT
 SPC 1
* DECIMAL CONVERSION TABLE
CNVTBL FDB 10000
 FDB 1000
 FDB 100
 FDB 10
 FDB 1
 SPC 1
**************************************************
* SYSTEM CALL 32 (DELFIL) - DELETE FILE FROM     *
*                           DIRECTORY            *
*                                                *
* ENTRY REQUIREMENTS:  Y POINTS TO FCB FOR FILE  *
*                        (INITIALIZED)           *
*                                                *
* EXIT CONDITIONS:  B CONTAINS ERROR CODE        *
*                   Z FLAG IN CC SET PER B       *
*                   OTHERS PRESERVED             *
*************************************************
DELFL PSHS A,X,Y SAVE REGISTERS
 LBSR LOCFL LOOK UP THE FILE
 BNE DELFLX GO IF ERROR
 LDD DIRSTR,X CHECK FILE START BLOCK
 BNE DELFL1 GO IF NOT (SYSDIR) FILE
 LDB #ERR_IA REPORT ERROR (IA)
 BRA DELFLX
DELFL1 TST 16,X IS THIS LAST FILE?
 BNE DELFL3 GO IF NOT
 LDD DIRSTR,X SET UP NEW FREE BLOCK
 PSHS X SAVE POINTER
 LEAX DIRBUF,PCR POINT AT BUFFER START
 CMPX ,S IS THIS ONLY FILE?
 PULS X RESTORE POINTER
 BEQ DELFL2 GO IF ONLY FILE
 LDD DIREND-16,X SET FREE BLOCK FROM PREVIOUS FILE
 ADDD #1
DELFL2 STD DIRSTR+16,X SAVE FREE BLOCK START
DELFL3 LDD #16 SET MOVE LENGTH FOR 1 ENTRY
DELFL4 TFR X,Y SET UP POINTERS
 LEAX 16,X
 LBSR BLKMV MOVE THE BLOCK
 TST ,X AT END OF DIRECTORY?
 BNE DELFL4 LOOP IF NOT
DELFL5 CLR ,X+ CLEAR ENTIRE ENTRY
 DECB
 BNE DELFL5
 LDY 3,S POINT Y AT FCB
 LDA FCBDRN,Y GET DRIVE #
 LBSR WTDIR REWRITE THE DIRECTORY
DELFLX PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 33 (LOCDCB) - LOCATE DCB FOR DEVICE*
*                                                *
* ENTRY REQUIREMENTS:  D CONTAINS DEVICE ID      *
*                                                *
* EXIT CONDITIONS:  X CONTAINS ADDRESS OF DCB    *
*                     OR ZERO IF NOT FOUND       *
*                   Z FLAG IN CC SET PER X       *
*                   OTHERS UNCHANGED             *
**************************************************
LCDCB LEAX DEVLST,PCR POINT X AT BASE OF LIST
LCDCB1 LDX DCBLNK,X GET NEXT DCB ON LIST
 BEQ LCDCBX EXIT IF END OF LIST
 CMPD DCBDID,X DOES DEVICE ID MATCH?
 BNE LCDCB1 LOOP IF NOT
LCDCBX LEAX ,X SET/RESET Z FLAG
 RTS
 SPC 1
**************************************************
* SYSTEM CALL 34 (ADDDCB) - ADD DCB TO DEVICE    *
*                           LIST                 *
*                                                *
* ENTRY REQUIREMENTS:  X POINTS TO DCB TO ADD    *
*                        (DCB MUST BE SET UP)    *
*                                                *
* EXIT CONDITIONS:  ALL REGISTERS PRESERVED      *
*                     EXCEPT CC                  *
**************************************************
ADDCB PSHS D,X SAVE REGISTERS
 LDD DCBDID,X GET ID FOR THIS DEVICE
 BSR LCDCB IS IT ON THE LIST
 BNE ADDCBX EXIT IF IT IS
 LDX 2,S POINT X AT NEW DCB
 BEQ ADDCBX EXIT IF ZERO (ILLEGAL)
 LDD DEVLST,PCR GET CURRENT LIST POINTER
 STD DCBLNK,X LINK IN NEW DCB
 STX DEVLST,PCR SAVE NEW POINTER
ADDCBX PULS D,X,PC RESTORE & EXIT
 SPC 1
**************************************************
* SYSTEM CALL 35 (DELDCB) - DELETE DCB FROM      *
*                           DEVICE LIST          *
*                                                *
* ENTRY REQUIREMENTS:  D CONTAINS ID OF DEVICE   *
*                                                *
* EXIT CONDITIONS:  ALL REGISTERS PRESERVED      *
*                     EXCEPT CC                  *
**************************************************
DLDCB PSHS D,X,Y SAVE REGISTERS
 BSR LCDCB FIND THE DCB
 BEQ DLDCBX EXIT IF NOT FOUND
 TFR X,Y SAVE ADDRESS OF DCB
 LEAX DEVLST,PCR POINT TO BASE OF LIST
DLDCB1 CMPY DCBLNK,X IS THIS DCB LINKED TO TARGET?
 BEQ DLDCB2 GO IF YES
 LDX DCBLNK,X MOVE TO NEXT ONE
 BRA DLDCB1
DLDCB2 LDD DCBLNK,Y COPY END OF LIST
 STD DCBLNK,X
DLDCBX PULS D,X,Y,PC RESTORE & EXIT
 SPC 1
**************************************************
* SAVE COMMAND PROCESSOR                         *
**************************************************
SAVE PSHS A,X,Y,U SAVE REGISTERS
 TFR S,U SAVE S IN U (MARK STACK)
                                                ; pshs  D,X
                                                ; ldd   #32
                                                ; leax  SYSFCB,pcr
                                                ; jsr   DumpMem2
                                                ; lbsr  DSCRLF
                                                ; puls  D,X
                                                ;
                                                ; pshs  D,X
                                                ; ldd   #$80
                                                ; ldx   #$B300
                                                ; jsr   DumpMem2
                                                ; lbsr  DSCRLF
                                                ; puls  D,X
 LBSR SETFCB INITIALIZE FCB
                                                ; pshs  D,X
                                                ; ldd   #32
                                                ; leax  SYSFCB,pcr
                                                ; jsr   DumpMem2
                                                ; lbsr  DSCRLF
                                                ; puls  D,X
                                                ;
                                                ; pshs  D,X
                                                ; ldd   #$80
                                                ; ldx   #$B300
                                                ; jsr   DumpMem2
                                                ; lbsr  DSCRLF
                                                ; puls  D,X
 LBNE SAVEX GO IF ERROR
 LDD FCBSUF,Y GET FILE SUFFIX
 BNE SAVE1 GO IF NOT NULL
 LDD #$4D49 SET TO 'MI'
 STD FCBSUF,Y
SAVE1 LBSR HEXNM GET START ADDRESS
 lBNE SAVE6 GO IF ERROR
 PSHS D SAVE START
 LBSR HEXNM GET END ADDRESS
 lBNE SAVE6 GO IF ERROR
 CMPD ,S IS END < START?
 BLO SAVE6 ERROR IF YES
 PSHS D SAVE END
 LDD #$FFFF SET DEFAULT EXEC ADDRESS
 PSHS D
 LDA ,X CHECK CURRENT CHARACTER
 CMPA #CR END OF LINE?
 BEQ SAVE2 GO IF YES
 LBSR HEXNM GET EXEC ADDRESS
 BNE SAVE6 GO IF ERROR
 STD ,S SAVE IT
SAVE2 STX 7,S SAVE LINE POINTER
 LDD 2,S COMPUTE SEGMENT SIZE IN BYTES
 SUBD 4,S
 ADDD #1
 STD 2,S SAVE IT ON STACK
 TSTB 0 MOD 256?
 BEQ SAVE3 GO IF YES
 INCA SET SIZE AT 1 BLOCK
SAVE3 TFR A,B GET SIZE IN BLOCKS
 CLRA
 STD FCBSIZ,Y SAVE IN FCB
 LBSR LOCFL LOOK UP THE FILE
 BEQ SAVE4 GO IF FOUND
 CMPB #ERR_NF IS ERROR 'NF'?
 BNE SAVEX GO IF NOT
 BRA SAVE5
SAVE4 LBSR DELFL DELETE THIS FILE
 BNE SAVEX GO IF ERROR
SAVE5 LBSR LOCSP FIND SPACE FOR NEW FILE
 BNE SAVEX GO IF ERROR
 LDD DIRSTR,X MARK NEW BOUNDS
 ADDD FCBSIZ,Y
 SUBD #1
 STD DIREND,X
 LDD ,S GET EXEC ADDRESS
 STD DIREXT,X
 LDA FCBDRN,Y GET DRIVE #
 LBSR WTDIR WRITE THE DIRECTORY
 BNE SAVEX GO IF ERROR
 LDD DIRSTR,X GET START BLOCK #
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB

 IFDEF NEWSYSDCB
 pshs   d
 LDA 	FCBDRN,Y 	; GET DRIVE #
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	SAVEERR 	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	SAVEERR		; IF ZERO THEN ERROR
 puls   d
 ENDC
 
 STD DCBBLK,X SET UP FOR SAVE
 LDA FCBDRN,Y
 STA DCBDRV,X
 LDD 4,S
 STD DCBBUF,X
 LDD 2,S SEGMENT SIZE TO D
 LBSR MEMSV SAVE THE FILE SEGMENT
 BRA SAVEX EXIT (ERROR FLAG SET)
SAVE6 LDB #ERR_SN REPORT ERROR (SN)
SAVEX TFR U,S RESTORE STACK POINTER
 TSTB TEST ERROR STATUS
 PULS A,X,Y,U,PC RESTORE REGISTERS & EXIT
 SPC 1
 IFDEF NEWSYSDCB
SAVEERR LDB #ERR_ID ERROR 2 (ID)
 LEAS	2,S ; CLEAN UP STACK
 BRA 	SAVEX
 ENDC
 SPC 1
**************************************************
* LOAD COMMAND PROCESSOR                         *
**************************************************
LOAD PSHS A,X,Y,U SAVE REGISTERS
 LBSR SETFCB INITIALIZE SYSTEM FCB
 BNE LOADX GO IF ERROR
 LDD FCBSUF,Y GET THE SUFFIX
 BNE LOAD1 GO IF SET
 LDD #$4D49 SET TO 'MI'
 STD FCBSUF,Y
LOAD1 LDU #$FFFF SET DEFAULT LOAD ADDRESS
 LDA ,X GET CURRENT CHARACTER
 CMPA #CR END OF LINE?
 BEQ LOAD2 GO IF YES
 LBSR HEXNM GET LOAD ADDRESS
 BNE LOAD3 GO IF ERROR
 TFR D,U MOVE ADDRESS TO U
LOAD2 STX 1,S SAVE LINE POINTER
 LBSR LOCFL LOOK UP THE FILE
 BNE LOADX GO IF ERROR
 LDD DIRSTR,X GET START BLOCK #
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB

 IFDEF NEWSYSDCB
 pshs   d
 LDA 	FCBDRN,Y 	; GET DRIVE #
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	LOADERR 	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	LOADERR		; IF ZERO THEN ERROR
 puls   d
 ENDC

 STD DCBBLK,X SET UP FOR LOAD
 LDA FCBDRN,Y
 STA DCBDRV,X
 STU DCBBUF,X
 LBSR MEMLD LOAD THE SEGMENT
 BRA LOADX EXIT
LOAD3 LDB #ERR_SN REPORT ERROR (SN)
LOADX TSTB CHECK ERROR STATUS
 PULS A,X,Y,U,PC RESTORE & EXIT
 SPC 1
 IFDEF NEWSYSDCB
LOADERR LDB #ERR_ID ERROR 2 (ID)
 LEAS	2,S ; CLEAN UP STACK
 BRA 	LOADX
 ENDC
 SPC 1
**************************************************
* DELETE COMMAND PROCESSOR                       *
**************************************************
DELETE PSHS A,Y SAVE REGISTERS
 LBSR SETFCB INITIALIZE FCB
 BNE DELETX GO IF ERROR
 LBSR DELFL DELETE THE FILE
DELETX PULS A,Y,PC RESTORE REGISTERS
 SPC 1
**************************************************
* FILES COMMAND PROCESSOR                        *
**************************************************
FILES PSHS A,X SAVE REGISTERS
 LBSR GETDRV GET THE DRIVE #
 BNE FILESX GO IF ERROR
 STX 1,S SAVE LINE POINTER
 LBSR RDDIR READ THE DIRECTORY
 BNE FILESX GO IF ERROR
FILES1 PSHS X DISPLAY THE BANNER
 LEAX <DIRBNR,PCR
 SWI3
 FCB PSTRNG
 PULS X
 LDB #32 SET DISPLAY LIMIT ;JNS changed for convenience when running from emulation (32=max files in dir).
FILES2 PSHS B SAVE FILE COUNT
 LDA #15 SET FILL COUNTER
 STA ,-S
 LDB #8 DISPLAY FILE NAME
 BSR DSPNAM
 ABX BYPASS BLANKS
 LDB #2 SET FOR SUFFIX
 TST ,X ANY SUFFIX?
 BEQ FILES3 GO IF NOT
 LDA #'. DISPLAY A DOT
 SWI3
 FCB OUTCHR
 DEC ,S UPDATE OUTPUT COUNT
 BSR DSPNAM
FILES3 ABX BYPASS BLANKS
 LDB ,S+ FILL OUT NAME
 BSR SPFILL
 LDD ,X++ DISPLAY START BLOCK #
 LBSR DSDEC
 LDD ,X++ DISPLAY END BLOCK #
 LBSR DSDEC
 LDB #3 SPACE OVER 3
 BSR SPFILL
 LDD ,X++ DISPLAY EXTENSION
 SWI3
 FCB DSPDBY
 BSR DSCRLF BEGIN A NEW LINE
 PULS B GET PRINT LIMIT
 TST -16,X WAS THIS LAST ENTRY?
 BEQ FILES5 GO IF YES
 DECB DECREMENT LOOP COUNT
 BNE FILES2 LOOP IF NOT END
 PSHS X SAVE POINTER
 LEAX <CNTMSG,PCR PROMPT FOR CR
 SWI3
 FCB PSTRNG
 PULS X RESTORE X
FILES4 SWI3 GET A CHARACTER
 FCB INCHR
 CMPA #CR LOOP FOR CR
 BNE FILES4
 BSR DSCRLF
 BRA FILES1
FILES5 CLRB CLEAR ERROR STATUS
FILESX PULS A,X,PC RESTORE & RETURN
 SPC 1
* DISPLAY FILE NAME
DSPNAM TST ,X END OF NAME?
 BEQ DSNAMX GO IF YES
 LDA ,X+ DISPLAY THE CHARACTER
 SWI3
 FCB OUTCHR
 DEC 2,S DECREMENT FILL COUNT
 DECB DECREMENT COUNT
 BNE DSPNAM LOOP UNTIL ZERO
DSNAMX RTS
 SPC 1
* SPACE FILL LINE
SPFILL LDA #SP SPACE # OF TIMES SET BY B
 SWI3
 FCB OUTCHR
 DECB
 BNE SPFILL
 RTS
 SPC 1
* DISPLAY CR/LF
DSCRLF PSHS X SAVE X
 LEAX <CRLF,PCR DISPLAY CRLF
 SWI3
 FCB PSTRNG
 PULS X,PC
 SPC 1
DIRBNR FCB CR,LF
 FCC 'FILE NAME      START   END    EXT'
 SPC 1
CRLF FCB CR,LF+$80
 SPC 1
CNTMSG FCC '(CR TO CONTINUE)'
 FCB SP+$80
 SPC 1
* GET DRIVE # AND VALIDATE IT
GETDRV CLRB RESET ERROR FLAG
 IFDEF CURDRIVE
  LDA $f000+CURDRV SET DEFAULT DRIVE TO CURRENT DRIVE
 ELSE
  LDA #1 SET DEFAULT DRIVE #
 ENDC
 PSHS A
 LBSR CHKCHR GET NEXT CHARACTER
 BEQ GETDRX EXIT IF DELIMITER
 LBSR CHKDRV VALIDATE DRIVE #
 BNE GETDRX GO IF ERROR
 STA ,S SAVE DRIVE #
 LBSR CHKCHR CHECK NEXT CHARACTER
 BNE GETDR1 ERROR IF NOT DELIMITER
 LEAX -1,X BACK UP POINTER
 LBSR SKPSP BYPASS BLANKS
 BRA GETDRX GO IF END OF LINE
GETDR1 LDB #ERR_SN REPORT ERROR (SN)
GETDRX 
 LEAX -1,X ; JNS added for fix bug for I<CR> and F<CR>
 TSTB SET/RESET Z FLAG
 PULS A,PC RETURN WITH DRIVE # IN A
 SPC 1
**************************************************
* INIT COMMAND PROCESSOR                         *
**************************************************
INIT 
 PSHS A,X,Y SAVE REGISTERS
 BSR GETDRV GET THE DRIVE #
 LBNE INITX GO IF ERROR
 LEAY LINBUF,PCR POINT Y AT LINE BUFFER
INIT1 LDB ,X+ GET NEXT CHARACTER
 STB ,Y+ SAVE IN BUFFER
 CMPB #CR END OF LINE?
 BNE INIT1 LOOP IF NOT
 LEAX -1,X BACK UP POINTER
 STX 1,S SAVE LINE IT
 PSHS A SAVE DRIVE #
 LEAX >CONFRM,PCR DISPLAY CONFIRMATION REQUEST
 SWI3
 FCB PSTRNG
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB

 IFDEF NEWSYSDCB
 LDA 	,S 		; GET DRIVE #
 leax   SYSDCBn-DKDCB,X	; now x -> count of dcb's
 cmpa 	1,x		; GREATER THAN MAX NUMBER OF DRIVES (REDUNDANT CHECK)
 bgt 	INITERR 	; IF SO THEN ERROR
 tfr    a,b	
 aslb			; INDEX INTO WORD TABLE (FIRST ENTRY IS LENGTH)
 ldx    b,x		; GET THE DCB FOR THIS DRIVE
 BEQ	INITERR		; IF ZERO THEN ERROR
 ENDC

 PULS A GET DRIVE #
 
 IFDEF NEWSYSDCB
 pshs   x       save DCB pointer for later.
 ENDC

 STA DCBDRV,X SAVE DRIVE #
 SWI3 DISPLAY DRIVE #
 FCB DSPSBY
 SWI3 GET ACKNOWLEDGEMENT
 FCB INCHR
 CLRB PRESET ERROR (OK)
 CMPA #'Y OK TO INIT?
 BNE INITX EXIT IF NOT OK
 LDD #26 SET MOVE LENGTH
 LEAX SYSENT,PCR FROM SYSENT
 LEAY DIRBUF,PCR TO DIRBUF
 LBSR BLKMV MOVE IN SYSTEM ENTRIES
 LEAX D,Y POINT TO FREE SPACE
 LDD #DIRSIZ*256-26 CLEAR UNUSED ENTRIES
INIT2 CLR ,X+ CLEAR DIRECTORY
 DECB
 BNE INIT2
;JNS+ BUGFIX!
 TSTA
 BEQ INIT3
 DECA
 BRA INIT2
INIT3:
;JNS-
 LDX SYSDCB,PCR POINT X AT SYSTEM DCB

 IFDEF NEWSYSDCB
 ldx    ,s ; get the pointer to the DCB back.
 ENDC
 
 LEAY MPXBAS,PCR POINT Y AT MPX/9 CODING
 STY DCBBUF,X
 LDD MPXLOC,PCR GET MPX/9 DISK ADDRESS
 STD DCBBLK,X
 STD DIRBUF+DIRSTR+16,PCR SET START IN DIRECTORY
 LDD #MPXEND-MPXBAS SET SIZE IN D
 LBSR MEMSV WRITE THE MPX BLOCK
 BNE INITX GO IF ERROR
 LDD DCBBLK,X GET ENDING BLOCK #
 STD DIRBUF+DIREND+16,PCR PLUG DIRECTORY ENTRY
 ADDD #1 CALC NEXT FREE
 STD DIRBUF+DIRSTR+32,PCR PLUG IT
 LDA DCBDRV,X GET DRIVE #
 LBSR WTDIR WRITE THE DIRECTORY
 BNE INITX GO IF ERROR
 LEAY BOOT,PCR POINT TO BOOT CODING
 STY DCBBUF,X
 CLRA SET BLOCK # TO 0
 CLRB
 STD DCBBLK,X
 INCA SET BLOCK SIZE TO 256
 LBSR MEMSV
INITX 
 
 IFDEF NEWSYSDCB
 leas   2,s ; clean stack
 ENDC

 PULS A,X,Y,PC RESTORE & EXIT
 SPC 1
 IFDEF NEWSYSDCB
INITERR #ERR_ID ERROR 2 (ID)
;LEAS	2,S ; CLEAN UP STACK
 lBRA 	INITX
 ENDC
 SPC 1
* CONFIRMATION REQUEST
CONFRM FCB CR,LF
 FCC /ENTER 'Y' TO INIT DISK IN DRIVE/
 FCB SP+$80
 SPC 1
* SYSTEM DIRECTORY ENTRIES
SYSENT FCC '(SYSDIR)SY'
 FDB 0,DIRSIZ,0
 FCC 'MPX9'
 FCB 0,0,0,0
 FCC 'SY'
 SPC 1
**************************************************
* RENAME COMMAND PROCESSOR                       *
**************************************************
RENAME PSHS A,X,Y,U SAVE REGISTERS
 LBSR SETFCB INITIALIZE FCB
 BNE RENAMX GO IF ERROR
 TFR X,U SAVE LINE POINTER
 LBSR LOCFL FIND THE FILE
 BNE RENAMX GO IF ERROR
 LDA FCBDRN,Y SAVE DRIVE #
 PSHS A
 EXG X,U GET NEW NAME
 LBSR INFCB
 PULS A RESTORE DRIVE #
 BNE RENAMX GO IF ERROR
 STA FCBDRN,Y INSURE SAME DRIVE #
 STX 1,S SAVE LINE POINTER
 LEAX FCBNAM,Y POINT X AT NEW NAME
 EXG U,Y POINT Y AT OLD NAME
 LDD #10 SET LENGTH
 LBSR BLKMV MOVE THE NEW NAME
 LDA FCBDRN,U GET DRIVE #
 LBSR WTDIR REWRITE THE DIRECTORY
RENAMX PULS A,X,Y,U,PC RESTORE & EXIT
 SPC 1
**************************************************
* GO COMMAND PROCESSOR                           *
**************************************************
GO LDA ,X CHECK CURRENT LINE CHARACTER
 CMPA #CR END OF LINE?
 BEQ GO1 ERROR IF YES
 LBSR HEXNM GET THE ADDRESS
 BNE GO1 GO IF ERROR
 TFR D,PC CALL THE DESIRED ADDRESS
GO1 LDB #ERR_SN REPORT ERROR (SN)
 RTS
 SPC 1
**************************************************
* MON COMMAND PROCESSOR                          *
**************************************************
MON:
 SWI3 CALL MONITOR
 FCB MONITR
 CLRB RESET ERROR FLAG
 RTS
 SPC 1

 IFDEF CURDRIVE
**************************************************
* CURRENT COMMAND PROCESSOR                           *
**************************************************
CURRENT:
 LBSR GETDRV GET THE DRIVE #
 STA $f000+CURDRV SAVE CURRENT DRIVE
 CLRB
 RTS
 SPC 1
 ENDC

**************************************************
* SYSTEM CALL 36 (GETBAS) - GET MPX9 BASE ADDR   *
*                                                *
* ENTRY REQUIREMENTS:  none                      *
*                                                *
* EXIT CONDITIONS: X --> MPXRAM                  *
*                  Y --> MPXBAS                  *
*                  D LENGTH OF MPX9 CORE (MPXSIZ)*
**************************************************
GTBAS:
 LEAX    MPXRAM,PCR
 LEAY    MPXBAS,PCR
 LDD     #MPXSIZ
 RTS
 SPC 1

****************************************************
* SYSTEM CALL 37 (GETDCB) - Get System DCB address *
*                                                  *
* ENTRY REQUIREMENTS:  A - Drive #                 *
*                (only used if NEWSYSDCB defined)  *
*                                                  *
* EXIT CONDITIONS:  X --> DCB                      *
*                   A Changed                      *
*                   B CONTAINS ERROR CODE          *
*                   Z FLAG IN CC SET PER B         *
****************************************************
GTDCB:
 LDX    SYSDCB,PCR POINT X AT SYSTEM DCB
 IFDEF NEWSYSDCB
 leax   SYSDCBn-DKDCB,X ; now x -> count of dcb's
 cmpa   1,x
 bls    GTDCB2
 ldb    #ERR_ID ERROR 2 (ID)
 BRA    GTDCBX
GTDCB2:
 asla
 ldx    a,x
 clrb 
 ENDC
GTDCBX
 rts 



; DspFCB:              ; Y -> FCB
;        pshs   X,D
;        lbsr   DSCRLF
;        leax   FCB0,PCR
;        swi3 
;        FCB    PSTRNG
;        ldd    #32
;        tfr    y,x
;        jsr    [DumpMem2v]
;        lbsr   DSCRLF
;        leax   FCB1,PCR
;        swi3 
;        FCB    PSTRNG
;        lbsr   DSCRLF
;        puls   D,X,PC

; DspDCB:              ; a = prefix char, Y -> DCB
;        pshs   X,D
;        lbsr   DSCRLF
;        LDA    ,s
;        swi3 
;        FCB    OUTCHR
;        leax   DCB0,PCR
;        swi3 
;        FCB    PSTRNG
;        ldd    #32
;        tfr    y,x
;        jsr    [DumpMem2v]
;        lbsr   DSCRLF
;        leax   DCB1,PCR
;        swi3 
;        FCB    PSTRNG
;        lbsr   DSCRLF
;        puls   D,X,PC



; DCB0: FCS "      Nxt__ ID___ Drv@_ I/O@_  Er ex Dr blk__ buff@ tr"
; DCB1: FCS "       sc prev_ next_ ct data@  ty crc"

; FCB0: FCS "       RW D# Buff@ C# @Vect TY  S-Blk E-Blk Cur+B Prv+B"
; FCB1: FCS "       Nxt+B D-ext DataP xx xx  xx xx xx xx xx xx xx St"


* END OF MPX/9 OPERATING SYSTEM
MPXEND EQU *
 SPC 1
MPXSIZ EQU MPXEND-MPXBAS
 END MPX9EP
