 pragma 6809
 pragma cescapes

 TTL (C) 1984 Bjarne B{ckstr|m
 NAM 6809 FORTH : fig model
 OPT NOC,MAC,NOE

#pragma cescapes, condundefzero

*
*
** FORTH FOR 6809 by R. J. Talbot , Jr.
*
*** Talbot Microsystems
***
***
***
* This version of FORTH follows the model created by the 
*       The FORTH Interest Group (FIG)
*       PO Box 1105, San Carlos, Ck 94070
*       (415) 962-8653
* The model is described in a document which may be obtained from
* them for $15.00 entitled "fig-FORTH Installation Manual"
*
* This version was developed for a SWTPC 6809 system with FLEX, but
* all terminal io is done by internal code, so it is independent
* of the rom monitor or operating system such as FLEX. 
* The only systm dependent terminal I/O code which might need
* changing is the location of the control ACIA port in memory
* space - - the present assignment is to E004 and the data word is
* the control address + 1.
*
* All terminal I/O is done in three assembly language subroutines:
*       PEMIT - emits a character to terminal
*       PKEY - reads a character fron terminal ( no echo)
*       PQTERM - tests terminal for a character having been typed
*
* The FORTH words for disk I/O follow the model of the FORTH 
* Interest Group - there are both RAM simulation of disk I/O and real
* disk I/0 of standard FORTH SCREENS. Also, there is an interface
* which allows input or output using DOS format TEXT files , and 
* there is a link to the DOS ccmmand structure so that
* DOS comnands my be executed from FORTH, including read into
* or write from RAM: simulated disk using TAPE or DISK SAVE or LOAD.
*
* This 68'FORTH Vers 1.1 assembled machine code progran is available on
* a FLEX 9.0 soft-sectored 5-1/4" diskette or 
* on a 300 baud KCS cassette from TALBOT MICROSYSTETS.
*       The cassette version mnay be used in conjunction with the
* RAM simulation of disk to implement a cassette-only version or to
* modify the DOS interface to something other than FLEX.
*
* Advanced versions are available ( in 
* diskette forn only) which contains a full 6809 assembler in FORTH,
* a screen oriented FORTH source text editor , and many other 
* useful vocabularies -- contact TALEOT Microsystms. 
*
* This assembly source code is available ( on FLEX 9.0 soft sectored 
* 5 1/4" diskette only) -- contact TALBOT Microsystmes. 
*
*



*               MEMORY MAP
* addr contents                         pointer         init by
* **** ***************************      ***********     *********
* 0000 COLD start entry point
* 0003 Warm start entry point
*
* 0006 start of FORTH KERNEL 
*      COLD startup parameters, WARM startup paraaeters
*      common system variables
*      start of FORTH code
*               register Y              <== IP          ABORT
*        (W = X after LDX ,Y++ at NEXT) <== W
*
* lBEF end of FORTH KERNAL      dict links to FORTH further up. 
* 2000 -NBLK*(BUFSIZ+4)                                 FIRST, VIREGN
*       NBLK buffer sectors of VIRTUAL MEMORY
*       initialized with NBLK=4 so VIRBGN = 1BF0
* 2000                                                  VIREND
* registers and pointers for FOFiTH
* 2020 USER #1 table of variables       <== UP          UPINT
*
* 2050  "FORTH" ( a word )              <=      <====CONTENT
*                                         \==========CURRENT
*
* 207E  "TASK" (a word marking end of dict.)
* 2xxx                                  <== DP          DPINIT
* 2xxx  Dictionary grows |
*                     up |
*                        v
*               towards higher memory
*                        | (free space)
*               towards lower memory
*                 down   ^
* 2F30  DATA stack grows |      register U      <== SP  SP0,SINIT
* 2F30                                          <== IN  TIB
*       INPUT LINE BUFFER
*       holds up to 132 characters and
*       is scanned upward by IN starting
*       at TIB
* 2FB4  
* 3000  Return Stack Base       register S      <== RP  RINIT
*                                                       LO,DSMBGN
*       space to simulate a disk mass memory
* 4000                                                  HI,MEMTOP
*                                                          TOPMEM
*

;jns+
; PSYMON entry point equates
INCHR   EQU     $FD44
OUTCHR  EQU     $FD58
REQIO   EQU     $FD63

; Console DCB's
CIDCB   EQU     $F3EA
CEDCB   EQU     $F3EC
CODCB   EQU     $F3EE

; DCB function Codes
ReadFn	equ 1	; Read function code
WritFn	equ 2	; Write function code
StatFn	equ 4	; Status function code
CntlFn	equ 8	; Device Control function code

RAMv            equ $ffde
DspSByv         equ $ffe0
DspDByv         equ $ffe2
GetHexv         equ $ffe4
PStringv        equ $ffe6
InChrv          equ $ffe8
OutChrv         equ $ffea
ReqIOv          equ $ffec
MonEntv         equ $ffee
;jns-

; *****************************************************************************
; ********      C O N F I G U R A T I O N   P A R A M E T E R S        ********
; *****************************************************************************

NBLK   SET 4    ; # of disc buffer blocks for virtual memory
BUFSIZ EQU 256  ; # of bytes per disk sector
PRGBGN EQU 0    ; beginning of FORTH program COLD entry point
                ; WARM entry point is PRGBGN + 3
VIRBGN SET VIREND-NBLK*(BUFSIZ+4)       ; assigns space for 4 BUFFERS
VIREND EQU USREND                       ; end of virtual memory buffers -- JNS was $2000
;* each block is BUFSIZ+4 bytes in size , holding BUFSIZ characters
;*       plus 4 bytes of control info
USRBGN EQU PRGBGN+$2000 ; beginning of user space                       -- JNS was $2000
USREND EQU USRBGN+$3000 ; end of user space, above is for disc sim.     -- jns was $3000 -- WAS +$2000
DSMBGN EQU $D000        ; begin of space availabel for disc sim.        -- jns was $3000 -- was USREND
DSMEND EQU DSMBGN+$1000 ; end of memory available for disc sim.         -- jns was $4000
MEMEND EQU DSMBGN
MEMTOP EQU DSMEND
*
*****************************************************************
* CONVENTIONS USED IM THIS PROGRAM ARE -
*
* IP    = register Y points towards the next word to execute
* SP    = register U points to LAST BYTE on the data stack
* RP    = register S points to LAST WORD on return stack
*         register X is used as a general index register for pointing
*               at things. For some indexing purposes, Y,U, or S are
*               saved so X and Y, U, or S may be used at same time.
* W      upon entry to a word, X = W = location of word containing
*               address of code to execute.
*
* When A and B are used seperately, in order to maintain compatibility 
*       with D register , A contains high byte, B the low byte. 
*
*****************************************************************
*

******** MACRO for creating dictionary headers ********
LASTNM SET 0
*
;WORDM MACRO
;NEXTNM  SET *
;        IFC &4,IMMEDIATE
;                FCB &1+$C0
;        ELSE
;                FCB &1+$80
;        ENDIF
;        IFNC &1,1
;        FCC `&2`
;        ENDIF
;*
;        FCB $80+'&3
;        FDB LASTNM
;LASTNM SET NEXTNM
;        IFC &5,USER
;&6      FDB DOUSER ignore error
;        FDB &7-UORIG
;        ENDIF
;        ENDM

IMMEDIATE       SET     1
NOIM            SET     0
USERVAR         SET     2

WORDM 	MACRO   NOEXPAND
NEXTNM 	SET 	*
        IFNE   \3+0             ; imm
                FCB   $C0+\1    ; 1st byte is no of char with sign and immed bit on if IMMEDIATE
        ELSE
                FCB   $80+\1    ; 1st byte is no of char with sign 
        endc
        FCS   \2        ; 1-\1 2-\2 3-\3 4-\4 5-\5
        FDB   LASTNM
LASTNM  SET   NEXTNM
        IFNE    \4+0            ; uservar
\5:             FDB     DOUSER
                FDB     \6-UORIG
        endc
	ENDM


*
;  ORG USRBGN     ; variables
; N RMB 10        ; used as scratch
; UP RMB 2        ; the pointyer to the base of current user's USER table (for multi-tasking)
; *
; * This system is shown for one user , but additional ones
; * may be added by allocating additional user tables and
; * words for switching the pointer between them. 
; * Alternatively , with SWTP SBUG dynamic memory assignment, it would
; * be possible to have a memory magenent procedure in KERNAL which
; * switches various USER 4k blocks in and out of this low space.
; *
; * Some of the next stuff is initialized during COLD and WARM starts.
; * Names correspond to FORTH words of similar (no X) name.
; *
; UORIG RMB 6
; ;* INIT ON COLD START
; XFENCE RMB 2    ; fence for FORGET
; XDP RMB 2       ; dictionary pointer
; XVOCL RMB 2     ; vocabulary linking
; XACIA RMB 2     ; address of acia
; XDELAY RMB 2    ; carriagereturn delay couut (# of nulls)
; XCOLUM RMB 2    ; carriage width
; XBKSP RMB 1     ; backspace character
; XBKSPE RMB 1    ; backspace echo
; XLINDL RMB 1    ; linedelete chcracter
; XLINDE RMB 1    ; linedelete echo
; ;* INIT BELOW ON COLD OR WARM START
; XSPZER RMB 2    ; initial top of data stack for this user
; XTIB RMB 2      ; start of terminal input buffer
; XRZERO RMB 2    ; initial top of return stack
; XFINA RMB 2     ; address of input file FCB
; XFOUTA RMB 2    ; address of output file PCB
; XWIDTH RMB 2    ; name field width
; XMSGBS RMB 2    ; Base Screen number for messages and GO
; XWARN RMB 2     ; warning message node ( 0 = no disk )
; ;* END OF INITIALIZED PARAMETERS
; XBLK FDB 0
; XIN FDB 0
; XOUT FDB 2
; XSCR FDB 0
; XOFSET FDB 0
; XCONT FDB TASK-7
; XCURR FDB TASK-7
; XSTATE FDB 0
; XBASE FDB 10
; XDPL FDB 2
; XFLD FDB 0
; XCSP FDB 0
; XRNUM FDB 0
; XHLD FDB 0
; ; IOSTAT FDB 0
; XCMDARG FDB 0   ; pointer to command line args
; XIBASE FDB 0   ; input base conversion


; *
;  FCB $C5 immediate
;  FCS 'FORTH'
;  FDB NOOP-7
; FORTH FDB DODOES,DOVOC,$81A0,TASKAA
;  FDB 0
;  FCC "(C) Bjarne B{ckstr|m 1984   "
; *
; TASKAA FCB $84
;  FCS 'TASK'
;  FDB FORTH-8
; *
; TASK FDB DOCOL,SEMIS
; REND EQU *
; *
 ORG PRGBGN
*
KERNAL LBRA PCENT
 LBRA WENT
*
CPUTYP FDB $6809
VERSON FDB $0101
 FDB 0
 FCB 20
 FCC "Bjarne B{ckstr|m    "
UPINIT FDB UORIG
*
FENCIN FDB TASKAA
DPINIT FDB REND
VOCINT FDB FORTH+8
ACIAI  FDB $F7FE        ;jns WAS $E004
DELINT FDB 4            ;JNS was 8
COLINT FDB 80
BACKSP FCB 8
BACKEC FCB 8
LINDEL FCB $1b          ;JNS escape
LINDEC FCB $20          ;JNS echo space
XVIRBG FDB VIRBGN
XVIRED FDB VIREND
XDSMBG FDB DSMBGN
XDSMED FDB DSMEND
*
SINIT FDB USREND-$D0
TIBINT FDB USREND-$D0
RINIT FDB USREND
FINA FDB 0
FOUTA FDB 0
WIDINT FDB 31
MSGBAS FDB 4            ; JNS SCREEN 4..5 CONTAINS MESSAGES.
WRNINT FDB 1
XUSE FDB 0 ;JNS was RMB 2
XPREV FDB 0 ;JNS was RMB 2
*
PULLDX PULU D
STORX STD ,X
 BRA NEXT
*
GETX LDD ,X
PUSHD PSHU D
 BRA NEXT
*
 WORDM 1,':',IMMEDIATE
COLON FDB DOCOL,QEXEC,SCSP,CURENT,AT,CONTXT,STORE
 FDB CREATE,RBRAK,PSCODE

DOCOL PSHS Y
 LEAY 2,X
*
* VIRTUAL FORTH MACHINE
*
NEXT LDX ,Y++
NEXT3 JMP [,X]
*
***********************
*
 WORDM 2,';S',
SEMIS FDB *+2
PSEMIS LDY ,S++
 BRA NEXT
*
 WORDM 7,'EXECUTE',
EXEC FDB *+2
 PULU X
 BRA NEXT3
*
 WORDM 3,'MON',
MON FDB PMON
*
 WORDM 3,'JSR',
JSR FDB *+2
 JSR [,U++]
 BRA NEXT
*
 WORDM 4,'EMIT'
EMIT FDB DOCOL,CEMIT,SEMIS

CEMIT FDB *+2
 PULU D
 TFR B,A
 LBSR PEMIT
 LDX XOUT
 LEAX 1,X
 STX XOUT
 BRA NEXT
*
 WORDM 3,'KEY'
KEY FDB DOCOL,CKEY,SEMIS

CKEY FDB *+2
 LBSR PKEY
 TFR A,B
 CLRA
 LBRA PUSHD
*
 WORDM 9,'?TERMINAL'
QTERM FDB *+2
 LBSR PQTER
 TFR A,B
 CLRA
 LBRA PUSHD
*
 WORDM 2,'CR'
CR FDB DOCOL,QTERM,ZBRAN
 FDB CR1-*
 FDB QUIT
CR1 FDB CLITER
 FCB $0A
 FDB EMIT,CLITER
 FCB $0D
 FDB EMIT,ZERO,OUT,STORE
 FDB LIT,XDELAY,AT,ZBRAN
 FDB CRE-*
 FDB LIT,XDELAY,AT,ZERO,XDO
CR2 FDB ZERO,EMIT,XLOOP
 FDB CR2-*
CRE FDB SEMIS
IFCOLD FCB $FF
*
;JNS+
PCENT:
        stx XCMDARG ; SAVE COMMAND LINE ARGUMNETS FOR LATER.
        bra CENT
;JNS-
*
 WORDM 4,'COLD'
COLD FDB *+2
CENT LDU DPINIT ; top of destination
 LDX #ERAM      ; top of stuff to move
COLD2 LDA ,-X
 STA ,-U
 CMPX #RAM
 BNE COLD2
 LDA #$FF
 STA IFCOLD
;JNS+
; LDS XVIRED     ; put stack somewhere safe              ; JNS change for mpx9 (SHOULD SAVE THIS AND RELOAD IT ???)
;; STS XRZERO
 lds    #$7ff0  ; JNS stack base must be below $8000 prob. due to doing singed compars on something.
 ; LDS    #$4000  ; JNS
 STS RINIT
;JNS-
 LDX XVIRED
 STX LIMIT+2
 LDX XVIRBG
 STX XUSE
 STX XPREV
 STX FIRST+2
 LDA #0
COLD8 STA ,X+   ; Clear virtual disk buffers.
 CMPX XVIRED
 BNE COLD8
 STA ,X
 LDX XDSMED
 STX HI+2
 LDX XDSMBG
 STX LO+2
 LDU #XLINDE+1
 LDX #LINDEC+1
COLDZ LDA ,-X
 STA ,-U
 CMPX #FENCIN
 BNE COLDZ
 BRA WENT
*
 WORDM 4,'WARM'
WARM FDB *+2
WENT LDU #XWARN+2
 LDX #WRNINT+2
WARM2 LDA ,-X
 STA ,-U
 CMPX #SINIT
 BNE WARM2
;JNS+
 ; LDU XSPZER             ; U is SP                       ; JNS change for mpx9
 leau   -$200,s          ; leave space for return stack. and TIB
 stu    XTIB
 stu    TIBINT
 stu    XSPZER
 stu    SINIT
;JNS-
 LDX UPINIT
 STX UP                 ; init user pointer
 LDY #ABORT+2   ; Y is IP, init to first instruction in ABORT
INTSPC NOP      ; ****
 NOP            ; **** here is a place to jump to a special initialization routine if needed.
 NOP            ; ****
 LBRA RPSTOR+2
*
 WORDM 3,'SP@'
SPAT FDB *+2
 LEAX ,U
 PSHU X
 LBRA NEXT
*
 WORDM 3,'SP!'
SPSTOR FDB *+2
 LDU XSPZER
 LBRA NEXT
*
 WORDM 3,'RP!'
RPSTOR FDB *+2
 LDS XRZERO
 LBRA NEXT
*
 WORDM 3,'LIT'
LIT FDB *+2
 LDD ,Y++
 LBRA PUSHD
*
CLITER FDB *+2
 LDB ,Y+
 CLRA
 LBRA PUSHD
*
 WORDM 6,'BRANCH'
BRAN FDB ZBYES
*
 WORDM 7,'0BRANCH'
ZBRAN FDB *+2
 LDD ,U++
 BNE ZBNO
ZBYES TFR Y,D
 ADDD ,Y
 TFR D,Y
 LBRA NEXT
*
ZBNO LEAY 2,Y
 LBRA NEXT
*
 WORDM 6,'(LOOP)'
XLOOP FDB *+2
 LDD #1
 BRA XPLOP2
*
 WORDM 7,'(+LOOP)'
XPLOOP FDB *+2
 PULU D
XPLOP2 TSTA
 BPL XPLOF
 ADDD ,S
 STD ,S
 ANDCC #1
 SBCB 3,S
 SBCA 2,S
 BPL ZBYES
 BRA XPLONO

XPLOF ADDD ,S
 STD ,S
 SUBD 2,S
 BMI ZBYES
XPLONO LEAS 4,S
 BRA ZBNO
*
 WORDM 4,'(DO)'
XDO FDB *+2
 PULU D
 PULU X
 PSHS X,D
 LBRA NEXT
*
 WORDM 1,'I'
I FDB *+2
 LDD ,S
 LBRA PUSHD
*
 WORDM 1,'J'
J FDB *+2
 LDD 4,S
 LBRA PUSHD
*
 WORDM 1,'K'
K FDB *+2
 LDD 8,S
 LBRA PUSHD
*
 WORDM 5,'DIGIT'
DIGIT FDB *+2
 LDA 3,U
 SUBA #$30
 BMI DIGIT2
 CMPA #$A
 BMI DIGIT0
 CMPA #$11
 BMI DIGIT2
 CMPA #$2B
 BPL DIGIT2
 SUBA #7
DIGIT0 CMPA 1,U
 BPL DIGIT2
 LDB #1
 STA 3,U
DIGIT1 STB 1,U
 LBRA NEXT

DIGIT2 CLRB
 LEAU 2,U
 STB 0,U
 BRA DIGIT1
*
 WORDM 6,'(FIND)'
PFIND FDB *+2
PD EQU N
PA0 EQU N+2
PA EQU N+4
PCHR EQU N+6
 PSHS Y
PFIND0 PULU X,Y
 STY PA0

PFIND1 LDB ,X+
 STB PCHR
 ANDB #$3F
 LDY PA0
 CMPB ,Y+
 BNE PFIND4

PFIND2 LDA ,Y+
 TST ,X
 BPL PFIND8
 ORA #$80
 CMPA ,X+
 BEQ FOUND

PFIND3 LDX 0,X
 BNE PFIND1
* not found :
 TFR X,D
 BRA PFINDE

PFIND8 CMPA ,X+
 BEQ PFIND2

PFIND4 LDB ,X+
 BPL PFIND4
 BRA PFIND3
* found :
FOUND LEAX 4,X
 LDB PCHR
 CLRA
 PSHU X,D
 LDB #1

PFINDE PULS Y
 LBRA PUSHD

 WORDM 7,'ENCLOSE'
;* NOTE: FC means offset (bytes) to First Character of next word 
;*       EW   "     "    to End of next Word
;*       NC   "     "    to Next Character to start next enclose at
ENCLOS FDB *+2
 PULU D         ; get char off stack to use as delim into D
 LDX ,U         ; addr to begin
 CLR N
 STB N+1        ; save delim to use
;       wait for a non-delimiter or NUL
ENCL2 LDA 0,X
 BEQ ENCL6
; ;JNS+
;  cmpa   #$0d
;  beq    ENCL6
; ;JNS-
 CMPA N+1       ; check for delim
 BNE ENCL3
 LEAX 1,X
 INC N
 BRA ENCL2
;* found first character, Push PC
ENCL3 LDB N
 CLRA
 PSHU D
;* wait for a delimiter or NUL
ENCL4 LDA ,X+
 BEQ ENCL7
; ;JNS+
;  cmpa   #$0d
;  beq    ENCL7
; ;JNS-
 CMPA N+1       ; check for delim
 BEQ ENCL5
 INC N
 BRA ENCL4
;* found EW, Push it
ENCL5 LDB N
 CLRA
 PSHU D
;* advance and push NC
 INCB
 LBRA PUSHD
;* found NUL before non delimiter, therefore , no word
ENCL6 LDB N     ; A is zero
 PSHU D
 INCB
 BRA ENCL7P
;* found NUL following word instead of SPACE
ENCL7 LDB N
ENCL7P PSHU D   ; save EW
ENCL8 LDB N     ; save NC
 LBRA PUSHD
*
 WORDM 5,'CMOVE'
CMOVE FDB *+2
 BSR PCMOVE
 LBRA NEXT

PCMOVE PSHS X,Y
 PULU D,X,Y
 PSHS U
 TFR Y,U
 TFR D,Y
 LEAY 1,Y
CMOV2 LEAY -1,Y
 BEQ CMOV3
 LDA ,U+
 STA ,X+
 BRA CMOV2
CMOV3 PULS U
 PULS X,Y
 RTS
*
 WORDM 2,'U*'
USTAR FDB *+2
 BSR USTARS
 LEAU 2,U
 LBRA PUSHD
*
USTARS LDX #17
 LDD #0
USTAR2 ROR 2,U
 ROR 3,U
 LEAX -1,X
 BEQ USTAR4
 BCC USTAR3
 ADDD ,U
USTAR3 RORA
 RORB
 BRA USTAR2
USTAR4 RTS
*
 WORDM 2,'U/'
USLASH FDB *+2
 LDD 2,U
 LDX 4,U
 STX 2,U
 STD 4,U
 ASL 3,U
 ROL 2,U
 LDX #$10
USLL1 ROL 5,U
 ROL 4,U
 LDD 4,U
 SUBD ,U
 ANDCC #$FE
 BMI USLL2
 STD 4,U
 ORCC #1
USLL2 ROL 3,U
 ROL 2,U
 LEAX -1,X
 BNE USLL1
 LEAU 2,U
 LBRA NEXT
*
 WORDM 3,'AND'
AND FDB *+2
 PULU D
 ANDB 1,U
 ANDA 0,U
PUTD STD ,U
 LBRA NEXT
*
 WORDM 2,'OR'
OR FDB *+2
 PULU D
 ORB 1,U
 ORA 0,U
 BRA PUTD
*
 WORDM 3,'XOR'
XOR FDB *+2
 PULU D
 EORB 1,U
 EORA 0,U
 BRA PUTD
*
 WORDM 1,'+'
PLUS FDB *+2
 PULU D
 ADDD ,U
 LBRA PUTD
*
 WORDM 2,'D+'
DPLUS FDB *+2
 LDD 2,U
 ADDD 6,U
 STD 6,U
 LDD ,U
 ADCB 5,U
 ADCA 4,U
 LEAU 4,U
 STD ,U
 LBRA NEXT
*
 WORDM 5,'MINUS'
MINUS FDB *+2
 NEG 1,U
 BCS MINUS2
 NEG ,U
 LBRA NEXT
MINUS2 COM ,U
 LBRA NEXT
*
 WORDM 6,'DMINUS'
DMINUS FDB *+2
 COM 0,U
 COM 1,U
 COM 2,U
 NEG 3,U
 BNE DMINX
 INC 2,U
 BNE DMINX
 INC 1,U
 BNE DMINX
 INC ,U
DMINX LBRA NEXT
*
 WORDM 2,'1+'
ONEP FDB *+2
 LDD ,U
 ADDD #1
 LBRA PUTD
*
 WORDM 2,'2+'
TWOP FDB *+2
 LDD #2
 ADDD ,U
 LBRA PUTD
*
 WORDM 2,'1-'
ONEM FDB *+2
 LDD ,U
 SUBD #1
 LBRA PUTD
*
 WORDM 2,'2-'
TWOM FDB *+2
 LDD ,U
 SUBD #2
 LBRA PUTD
*
 WORDM 2,'M*'
MSTAR FDB DOCOL,OVER,OVER,XOR,TOR,ABS,SWAP,ABS,USTAR
 FDB FROMR,DSETSN,SEMIS
*
 WORDM 1,'*'
STAR FDB DOCOL,MSTAR,DROP,SEMIS
*
 WORDM 2,'M/'
MSLASH FDB DOCOL,OVER,TOR,TOR,DABS,R,ABS,USLASH,FROMR,R,XOR
 FDB SETSN,SWAP,FROMR,SETSN,SWAP,SEMIS
*
 WORDM 4,'/MOD'
SLMOD FDB DOCOL,TOR,STOD,FROMR,MSLASH,SEMIS
*
 WORDM 1,'/'
SLASH FDB DOCOL,SLMOD,SWAP,DROP,SEMIS
*
 WORDM 3,'MOD'
MOD FDB DOCOL,SLMOD,DROP,SEMIS
*
 WORDM 5,'*/MOD'
SSMOD FDB DOCOL,TOR,MSTAR,FROMR,MSLASH,SEMIS
*
 WORDM 2,'*/'
SSLASH FDB DOCOL,SSMOD,SWAP,DROP,SEMIS
*
 WORDM 5,'M/MOD'
MSMOD FDB DOCOL,TOR,ZERO,R,USLASH,FROMR,SWAP,TOR
 FDB USLASH,FROMR,SEMIS
*
 WORDM 3,'ABS'
ABS FDB DOCOL,DUP,ZLESS,ZBRAN
 FDB ABS2-*
 FDB MINUS
ABS2 FDB SEMIS
*
 WORDM 4,'DABS'
DABS FDB DOCOL,DUP,ZLESS,ZBRAN
 FDB DABS2-*
 FDB DMINUS
DABS2 FDB SEMIS
*
 WORDM 1,'<'
LESS FDB *+2
 PULU D
 CMPA 0,U
 BGT LESST
 BNE LESSF
 CMPB 1,U
 BHI LESST
LESSF CLRB
 BRA LESSX
LESST LDB #1
LESSX CLRA
 LBRA PUTD
*
 WORDM 4,'S->D'
STOD FDB *+2
 LDD #0
 TST ,U
 BPL STOD2
 COMA
 COMB
STOD2 STD ,--U
 LBRA NEXT
*
 WORDM 2,'+-'
SETSN FDB DOCOL,ZLESS,ZBRAN
 FDB SETSN2-*
 FDB MINUS
SETSN2 FDB SEMIS
*
 WORDM 3,'D+-'
DSETSN FDB DOCOL,ZLESS,ZBRAN
 FDB DSETS2-*
 FDB DMINUS
DSETS2 FDB SEMIS
 LEAU 2,U
 LBRA NEXT
*
 WORDM 2,'0='
ZEQU FDB *+2
 CLRA
 CLRB
 LDX ,U
 BNE ZEQU2
 INCB
ZEQU2 STD ,U
 LBRA NEXT
*
 WORDM 2,'0<'
ZLESS FDB *+2
 LDA #$80
 ANDA ,U
 BEQ ZLESS2
 CLRA
 LDB #1
 LBRA PUTD
ZLESS2 CLRB
 LBRA PUTD
*
 WORDM 5,'LEAVE'
LEAVE FDB *+2
 LDD ,S
 STD 2,S
 LBRA NEXT
*
 WORDM 2,'>R'
TOR FDB *+2
 PULU D
 PSHS D
 LBRA NEXT
*
 WORDM 2,'R>'
FROMR FDB *+2
 PULS D
 PSHU D
 LBRA NEXT
*
 WORDM 1,'R'
R FDB I+2
*
 WORDM 4,'OVER'
OVER FDB *+2
 LDD 2,U
 LBRA PUSHD
*
 WORDM 4,'DROP'
DROP FDB *+2
 LEAU 2,U
 LBRA NEXT
*
 WORDM 4,'SWAP'
SWAP FDB *+2
 PULU D,X
 EXG D,X
 PSHU D,X
 LBRA NEXT
*
 WORDM 3,'DUP'
DUP FDB *+2
 LDD ,U
 LBRA PUSHD
*
 WORDM 2,'+!'
PSTORE FDB *+2
 LDX ,U++
 LDD ,U++
 ADDD ,X
 STD ,X
 LBRA NEXT
*
 WORDM 1,'@'
AT FDB *+2
 LDD [,U]
 LBRA PUTD
*
 WORDM 2,'C@'
CAT FDB *+2
 LDB [,U]
 CLRA
 LBRA PUTD
*
 WORDM 1,'!'
STORE FDB *+2
 PULU X
 PULU D
 STD ,X
 LBRA NEXT
*
 WORDM 2,'C!'
CSTORE FDB *+2
 PULU X
 PULU D
 STB ,X
 LBRA NEXT
*
 WORDM 7,'<BUILDS'
BUILDS FDB DOCOL,ZERO,CON,SEMIS
*
 WORDM 5,'DOES>'
DOES FDB DOCOL,FROMR,LATEST,PFA,STORE,PSCODE

DODOES PSHS Y
 LDY 2,X
 LEAX 4,X
 PSHU X
 LBRA NEXT
*
 WORDM 6,'TOGGLE'
TOGGLE FDB DOCOL,OVER,CAT,XOR,SWAP,CSTORE,SEMIS
*
 WORDM 1,';',IMMEDIATE
SEMI FDB DOCOL,QCSP,COMPIL,SEMIS,SMUDGE,LBRAK,SEMIS
*
 WORDM 8,'CONSTANT'
CON FDB DOCOL,CREATE,SMUDGE,COMMA,PSCODE

DOCON LDD 2,X
 LBRA PUSHD
*
 WORDM 8,'VARIABLE'
VAR FDB DOCOL,CON,PSCODE

DOVAR LEAX 2,X
 PSHU X
 LBRA NEXT
*
 WORDM 1,'0'
ZERO FDB DOCON
 FDB 0
*
 WORDM 1,'1'
ONE FDB DOCON
 FDB 1
*
 WORDM 1,'2'
TWO FDB DOCON
 FDB 2
*
 WORDM 1,'3'
THREE FDB DOCON
 FDB 3
*
 WORDM 2,'BL'
BL FDB DOCON
 FDB $20
*
 WORDM 5,'FIRST'
FIRST FDB DOCON
 FDB VIRBGN
*
 WORDM 5,'LIMIT'
LIMIT FDB DOCON
 FDB VIREND
*
 WORDM 4,'USER'
USER FDB DOCOL,CON,PSCODE

DOUSER LDD 2,X
 ADDD UP
 LBRA PUSHD
*
 WORDM 7,'+ORIGIN'
PORIG FDB DOCOL,LIT,PRGBGN,PLUS,SEMIS
*
 WORDM 2,'S0'
SZERO FDB DOUSER
 FDB XSPZER-UORIG
*
 WORDM 2,'R0'
RZERO FDB DOUSER
 FDB XRZERO-UORIG
*
 WORDM 3,'TIB',,USERVAR,TIB,XTIB
 WORDM 5,'WIDTH',,USERVAR,WIDTH,XWIDTH
 WORDM 7,'WARNING',,USERVAR,WARN,XWARN
 WORDM 5,'FENCE',,USERVAR,FENCE,XFENCE
 WORDM 2,'DP',,USERVAR,DP,XDP
 WORDM 8,'VOC-LINK',,USERVAR,VOCLIN,XVOCL
 WORDM 3,'BLK',,USERVAR,BLK,XBLK
 WORDM 2,'IN',,USERVAR,IN,XIN
 WORDM 3,'OUT',,USERVAR,OUT,XOUT
 WORDM 3,'SCR',,USERVAR,SCR,XSCR
 WORDM 6,'OFFSET',,USERVAR,OFSET,XOFSET
 WORDM 7,'CONTEXT',,USERVAR,CONTXT,XCONT
 WORDM 7,'CURRENT',,USERVAR,CURENT,XCURR
 WORDM 5,'STATE',,USERVAR,STATE,XSTATE
 WORDM 4,'BASE',,USERVAR,BASE,XBASE
 WORDM 3,'DPL',,USERVAR,DPL,XDPL
 WORDM 3,'FLD',,USERVAR,FLD,XFLD
 WORDM 3,'CSP',,USERVAR,CSP,XCSP
 WORDM 2,'R#',,USERVAR,RNUM,XRNUM
 WORDM 3,'HLD',,USERVAR,HLD,XHLD
 WORDM 7,'COLUMNS',,USERVAR,COLUMS,XCOLUM
 WORDM 6,'CMDARG',,USERVAR,CMDARG,XCMDARG
 WORDM 5,'IBASE',,USERVAR,IBASE,XIBASE

*
 WORDM 4,'HERE'
HERE FDB DOCOL,DP,AT,SEMIS
*
 WORDM 5,'ALLOT'
ALLOT FDB DOCOL,DP,PSTORE,SEMIS
*
 WORDM 1,"\,"
COMMA FDB DOCOL,HERE,STORE,TWO,ALLOT,SEMIS
*
 WORDM 2,"C\,"
CCOMM FDB DOCOL,HERE,CSTORE,ONE,ALLOT,SEMIS
*
 WORDM 1,'-'
SUB FDB DOCOL,MINUS,PLUS,SEMIS
*
 WORDM 1,'='
EQUAL FDB DOCOL,SUB,ZEQU,SEMIS
*
 WORDM 1,'>'
GREAT FDB DOCOL,SWAP,LESS,SEMIS
*
 WORDM 5,'SPACE'
SPACE FDB DOCOL,BL,EMIT,SEMIS
*
 WORDM 3,'MIN'
MIN FDB DOCOL,OVER,OVER,GREAT,ZBRAN
 FDB MIN2-*
 FDB SWAP
MIN2 FDB DROP,SEMIS
*
 WORDM 3,'MAX'
MAX FDB DOCOL,OVER,OVER,LESS,ZBRAN
 FDB MAX2-*
 FDB SWAP
MAX2 FDB DROP,SEMIS
*
 WORDM 4,'-DUP'
DDUP FDB DOCOL,DUP,ZBRAN
 FDB DDUP2-*
 FDB DUP
DDUP2 FDB SEMIS
*
 WORDM 8,'TRAVERSE'
TRAV FDB DOCOL,SWAP
TRAV2 FDB OVER,PLUS,CLITER
 FCB $7F
 FDB OVER,CAT,LESS,ZBRAN
 FDB TRAV2-*
 FDB SWAP,DROP,SEMIS
*
 WORDM 6,'LATEST'
LATEST FDB DOCOL,CURENT,AT,AT,SEMIS
*
 WORDM 3,'LFA'
LFA FDB DOCOL,CLITER
 FCB 4
 FDB SUB,SEMIS
*
 WORDM 3,'CFA'
CFA FDB DOCOL,TWO,SUB,SEMIS
*
 WORDM 3,'NFA'
NFA FDB DOCOL,CLITER
 FCB 5
 FDB SUB,ONE,MINUS,TRAV,SEMIS
*
 WORDM 3,'PFA'
PFA FDB DOCOL,ONE,TRAV,CLITER
 FCB 5
 FDB PLUS,SEMIS
*
 WORDM 4,'!CSP'
SCSP FDB DOCOL,SPAT,CSP,STORE,SEMIS
*
 WORDM 6,'?ERROR'
QERR FDB DOCOL,SWAP,ZBRAN
 FDB QERR2-*
 FDB ERROR,BRAN
 FDB QERR3-*
QERR2 FDB DROP
QERR3 FDB SEMIS
*
 WORDM 5,'?COMP'
QCOMP FDB DOCOL,STATE,AT,ZEQU,CLITER
 FCB $11
 FDB QERR,SEMIS
*
 WORDM 5,'?EXEC'
QEXEC FDB DOCOL,STATE,AT,CLITER
 FCB $12
 FDB QERR,SEMIS
*
 WORDM 6,'?PAIRS'
QPAIRS FDB DOCOL,SUB,CLITER
 FCB $13
 FDB QERR,SEMIS
*
 WORDM 4,'?CSP'
QCSP FDB DOCOL,SPAT,CSP,AT,SUB,CLITER
 FCB $14
 FDB QERR,SEMIS
*
 WORDM 8,'?LOADING'
QLOAD FDB DOCOL,BLK,AT,ZEQU,CLITER
 FCB $16
 FDB QERR,SEMIS
*
 WORDM 7,'COMPILE'
COMPIL FDB DOCOL,QCOMP,FROMR,DUP,TWOP,TOR,AT,COMMA,SEMIS
*
 WORDM 1,'[',IMMEDIATE
LBRAK FDB DOCOL,ZERO,STATE,STORE,SEMIS
*
 WORDM 1,']',NOIM
RBRAK FDB DOCOL,CLITER
 FCB $C0
 FDB STATE,STORE,SEMIS
*
 WORDM 6,'SMUDGE'
SMUDGE FDB DOCOL,LATEST,CLITER
 FCB $20
 FDB TOGGLE,SEMIS
*
 WORDM 3,'HEX'
HEX FDB DOCOL,CLITER
 FCB 16
 FDB BASE,STORE,SEMIS
*
 WORDM 7,'DECIMAL'
DEC FDB DOCOL,CLITER
 FCB 10
 FDB BASE,STORE,SEMIS
*
 WORDM 7,'(;CODE)'
PSCODE FDB DOCOL,FROMR,LATEST,PFA,CFA,STORE,SEMIS
*
 WORDM 5,';CODE',IMMEDIATE
SEMIC FDB DOCOL,QCSP,COMPIL,PSCODE,SMUDGE,LBRAK,QSTACK,SEMIS
*
 WORDM 5,'COUNT',NOIM
COUNT FDB DOCOL,DUP,ONEP,SWAP,CAT,SEMIS
*
 WORDM 4,'TYPE'
TYPE FDB DOCOL,DDUP,ZBRAN
 FDB TYPE3-*
 FDB OVER,PLUS,SWAP,XDO
TYPE2 FDB I,CAT,EMIT,XLOOP
 FDB TYPE2-*
 FDB BRAN
 FDB TYPE4-*
TYPE3 FDB DROP
TYPE4 FDB SEMIS
*
 WORDM 9,'-TRAILING'
DTRAIL FDB DOCOL,DUP,ZERO,XDO
DTRAL2 FDB OVER,OVER,PLUS,ONE,SUB,CAT,BL
 FDB SUB,ZBRAN
 FDB DTRAL3-*
 FDB LEAVE,BRAN
 FDB DTRAL4-*
DTRAL3 FDB ONE,SUB
DTRAL4 FDB XLOOP
 FDB DTRAL2-*
 FDB SEMIS
*
NEXTNM SET *
 FCB $C1
 FCB $80+'"
 FDB LASTNM
LASTNM SET NEXTNM
QUOTE FDB DOCOL,CLITER
 FCB $22
 FDB STATE,AT,ZBRAN
 FDB QUOTE1-*
 FDB COMPIL,PQUOTE,WORD,HERE,CAT,ONEP,ALLOT,BRAN
 FDB QUOTE2-*
QUOTE1 FDB WORD,HERE,HERE,CAT,ONEP,PAD,SWAP,CMOVE,PAD
QUOTE2 FDB SEMIS
*
NEXTNM SET *
*
 FCB $83
 FCC /("/
 FCB $80+')
 FDB LASTNM
LASTNM SET NEXTNM
PQUOTE FDB DOCOL,R,DUP,CAT,ONEP,FROMR,PLUS,TOR,SEMIS
*
NEXTNM SET *
*
 FCB $84
 FCC /(."/
 FCB $80+')
 FDB LASTNM
LASTNM SET NEXTNM
PDOTQ FDB DOCOL,R,COUNT,DUP,ONEP,FROMR,PLUS,TOR,TYPE,SEMIS
*
NEXTNM SET *
 FCB $C2
 FCB '.
 FCB $80+'"
 FDB LASTNM
LASTNM SET NEXTNM
DOTQ FDB DOCOL,CLITER
 FCB $22
 FDB STATE,AT,ZBRAN
 FDB DOTQ1-*
 FDB COMPIL,PDOTQ,WORD,HERE,CAT,ONEP,ALLOT,BRAN
 FDB DOTQ2-*
DOTQ1 FDB WORD,HERE,COUNT,TYPE
DOTQ2 FDB SEMIS
*
 WORDM 6,'?STACK'
QSTACK FDB DOCOL,LIT
 FDB SINIT-PRGBGN
 FDB PORIG,AT,SPAT,LESS,ONE,QERR
QSTAC2 FDB SPAT
 FDB HERE,CLITER
 FCB $80
 FDB PLUS,LESS
 FDB TWO,QERR
QSTAC3 FDB SEMIS
*
 WORDM 3,'ROT'
ROT FDB DOCOL,TOR,SWAP,FROMR,SWAP,SEMIS
*
 WORDM 6,'EXPECT'
EXPECT FDB DOCOL,OVER,PLUS,OVER,XDO
EXPEC2 FDB KEY,DUP,LIT
 FDB XLINDL,CAT,EQUAL,ZBRAN
 FDB EXPECZ-*
;jns+
 FDB PDOTQ
 FCB 3
 FCC "***"
 FDB CR
;jns-
 FDB DROP,LIT,XLINDE,CAT,FROMR,DROP,OVER,ONEM,TOR,BRAN
 FDB EXPEC6-*
EXPECZ FDB DUP,LIT,XBKSP,CAT
 FDB EQUAL,ZBRAN
 FDB EXPEC3-*
 FDB DROP
;jns+ this echos a baskspace and a space before the original backspace is echoed.
 FDB LIT,XBKSPE,CAT,EMIT,BL,EMIT
;jns-
 FDB LIT
 FDB XBKSPE,CAT
 FDB OVER,I,EQUAL,DUP,FROMR,TWO,SUB,PLUS,TOR,SUB,BRAN
 FDB EXPEC6-*
EXPEC3 FDB DUP,CLITER
 FCB $D
 FDB EQUAL,ZBRAN
 FDB EXPEC4-*
 FDB LEAVE,DROP,BL,ZERO,BRAN
 FDB EXPEC5-*
EXPEC4 FDB DUP
EXPEC5 FDB I,CSTORE,ZERO,I,ONEP,STORE
EXPEC6 FDB EMIT,XLOOP
 FDB EXPEC2-*
 FDB DROP,SEMIS
*
 WORDM 5,'QUERY'
QUERY FDB DOCOL,TIB,AT,COLUMS,AT,EXPECT,ZERO,IN,STORE,SEMIS
*
NEXTNM SET *
 FCB $C1
 FCB $80
 FDB LASTNM
LASTNM SET NEXTNM
NULL FDB DOCOL,BLK,AT,ZBRAN
 FDB NULL2-*
 FDB ONE,BLK,PSTORE,ZERO,IN,STORE,BLK,AT,BSCR,MOD,ZEQU
 FDB ZBRAN
 FDB NULL1-*
 FDB QEXEC,FROMR,DROP
NULL1 FDB BRAN
 FDB NULL3-*
NULL2 FDB FROMR,DROP
NULL3 FDB SEMIS
*
 WORDM 4,'FILL' ( FILL MEMORY BEGIN-3,  QUAN-2,  BYTE-1 *)
FILL FDB DOCOL,SWAP,TOR,OVER,CSTORE,DUP,ONEP,FROMR,ONE
 FDB SUB,CMOVE,SEMIS
*
 WORDM 5,'ERASE'
ERASE FDB DOCOL,ZERO,FILL,SEMIS
*
 WORDM 6,'BLANKS'
BLANKS FDB DOCOL,BL,FILL,SEMIS
*
 WORDM 4,'HOLD'
HOLD FDB DOCOL,LIT,$FFFF,HLD,PSTORE,HLD,AT,CSTORE,SEMIS
*
 WORDM 3,'PAD'
PAD FDB DOCOL,HERE,CLITER
 FCB $44
 FDB PLUS,SEMIS
*
 WORDM 4,'WORD'
WORD FDB DOCOL,BLK,AT,ZBRAN
 FDB WORD2-*
 FDB BLK,AT,BLOCK,BRAN
 FDB WORD3-*
WORD2 FDB TIB,AT
WORD3 FDB IN,AT,PLUS,SWAP,ENCLOS,HERE,CLITER
 FCB 34
 FDB BLANKS,IN,PSTORE,OVER,SUB,TOR,R,HERE,CSTORE,PLUS
 FDB HERE,ONEP,FROMR,CMOVE,SEMIS
*
 WORDM 8,'(NUMBER)'
PNUMB FDB DOCOL
PNUMB2 FDB ONEP,DUP,TOR,CAT,IBASE,AT,DIGIT,ZBRAN
 FDB PNUMB4-*
 FDB SWAP,IBASE,AT,USTAR,DROP,ROT,IBASE
 FDB AT,USTAR,DPLUS,DPL,AT,ONEP,ZBRAN
 FDB PNUMB3-*
 FDB ONE,DPL,PSTORE
PNUMB3 FDB FROMR,BRAN
 FDB PNUMB2-*
PNUMB4 FDB FROMR,SEMIS
*
 WORDM 6,'NUMBER'
NUMB FDB DOCOL,ZERO,ZERO,ROT
 FDB BASE,AT,IBASE,STORE
 FDB DUP,ONEP,CAT,CLITER    ; SET IBASE = BASE
 FCB '$                     ; CHECK FOR $NNNN FORMAT.
 FDB EQUAL,ZBRAN
 FDB NUMB0-*
 FDB LIT,16,IBASE,STORE,ONEP ; JNS SET IBASE = 16, STEP OVER '$'
NUMB0
 FDB DUP,ONEP,CAT,CLITER
 FCB '-
 FDB EQUAL,DUP,TOR ; jns
 fdb PLUS,LIT,$FFFF
NUMB1 FDB DPL,STORE,PNUMB,DUP,CAT,BL,SUB,ZBRAN
 FDB NUMB2-*
 FDB DUP,CAT,CLITER
 FCB '.
 FDB SUB,ZERO,QERR,ZERO,BRAN
 FDB NUMB1-*
NUMB2 FDB DROP,FROMR,ZBRAN
 FDB NUMB3-*
 FDB DMINUS
NUMB3 FDB SEMIS
*
 WORDM 5,'-FIND'
DFIND FDB DOCOL,BL,WORD,HERE,CONTXT,AT,AT,PFIND,DUP,ZEQU,ZBRAN
 FDB DFIND2-*
 FDB DROP,HERE,LATEST,PFIND
DFIND2 FDB SEMIS
*
 WORDM 7,'(ABORT)'
PABORT FDB DOCOL,ABORT,SEMIS
*
 WORDM 5,'ERROR'
ERROR FDB DOCOL,WARN,AT,ZLESS,ZBRAN
 FDB ERROR2-*
 FDB PABORT
ERROR2 FDB HERE,COUNT,TYPE,PDOTQ
 FCB 4,7
 FCC " ? "
 FDB MESS,SPSTOR,IN,AT,BLK,AT,QUIT,SEMIS
*
 WORDM 3,'ID.'
IDDOT FDB DOCOL,PAD,CLITER
 FCB 32
 FDB CLITER
 FCB $5F
 FDB FILL,DUP,PFA,LFA,OVER,SUB,PAD,SWAP,CMOVE
 FDB PAD,COUNT,CLITER
 FCB 31
 FDB AND,TYPE,SPACE,SEMIS
*
 WORDM 6,'CREATE'
CREATE FDB DOCOL,DFIND,ZBRAN
 FDB CREAT2-*
 FDB DROP,PDOTQ
 FCB 8,7
 FCC "redef: "
 FDB NFA,IDDOT,CLITER
 FCB 4
 FDB MESS,SPACE
CREAT2 FDB HERE,DUP,CAT,WIDTH,AT,MIN,ONEP,ALLOT,DUP,CLITER
 FCB $A0
 FDB TOGGLE,HERE,ONE,SUB,CLITER
 FCB $80
 FDB TOGGLE,LATEST,COMMA,CURENT,AT,STORE,HERE,TWOP
 FDB COMMA,SEMIS
*
 WORDM 9,'[COMPILE]',IMMEDIATE
BCOMP FDB DOCOL,DFIND,ZEQU,ZERO,QERR,DROP,CFA,COMMA,SEMIS
*
 WORDM 7,'LITERAL',IMMEDIATE
LITER FDB DOCOL,STATE,AT,ZBRAN
 FDB LITER2-*
 FDB COMPIL,LIT,COMMA
LITER2 FDB SEMIS
*
 WORDM 8,'DLITERAL',IMMEDIATE
DLITER FDB DOCOL,STATE,AT,ZBRAN
 FDB DLITE2-*
 FDB SWAP,LITER,LITER
DLITE2 FDB SEMIS
*
 WORDM 9,'INTERPRET',NOIM
INTERP FDB DOCOL
INTER2 FDB DFIND,ZBRAN
 FDB INTER5-*
 FDB STATE,AT,LESS
 FDB ZBRAN
 FDB INTER3-*
 FDB CFA,COMMA,BRAN
 FDB INTER4-*
INTER3 FDB CFA,EXEC
INTER4 FDB QSTACK,BRAN
 FDB INTER7-*
INTER5 FDB HERE,NUMB,DPL,AT,ONEP,ZBRAN
 FDB INTER6-*
 FDB DLITER,BRAN
 FDB INTER7-*
INTER6 FDB DROP,LITER
INTER7 FDB QSTACK,BRAN
 FDB INTER2-*
*
 WORDM 9,'IMMEDIATE'
IMMED FDB DOCOL,LATEST,CLITER
 FCB $40
 FDB TOGGLE,SEMIS
*
 WORDM 10,'VOCABULARY'
VOCAB FDB DOCOL,BUILDS,LIT,$81A0,COMMA,CURENT,AT,CFA,COMMA
 FDB HERE,VOCLIN,AT,COMMA,VOCLIN,STORE,DOES
DOVOC FDB TWOP,CONTXT,STORE,SEMIS
 FDB 0
*
 WORDM 11,'DEFINITIONS'
DEFIN FDB DOCOL,CONTXT,AT,CURENT,STORE,SEMIS
*
 WORDM 1,'(',IMMEDIATE
PAREN FDB DOCOL,CLITER
 FCB ')
 FDB WORD,SEMIS
*
 WORDM 4,'QUIT',NOIM
QUIT FDB DOCOL,ZERO,BLK,STORE,LBRAK

QUIT2 FDB RPSTOR,CR,QUERY,INTERP,STATE,AT,ZEQU,ZBRAN
 FDB QUIT3-*
 FDB PDOTQ
 FCB 3
 FCC " OK"
QUIT3 FDB BRAN
 FDB QUIT2-*
*
 WORDM 5,'ABORT'
ABORT FDB DOCOL,SPSTOR,DEC,DRZERO,CR,PDOTQ
 FCB 18
 FCC "68'FORTH-09 VERS #"
 FDB LIT,VERSON,DUP,CAT,DOT,PDOTQ
 FCB 1
 FCB '.
 FDB ONEP,CAT,DOT
 FDB ZERO,IN,STORE,ZERO,BLK,STORE
 FDB FORTH,DEFIN,LIT,IFCOLD,CAT,ZBRAN
 FDB ABORTC-*
ABORTC FDB QUIT
*
 WORDM 2,'GO'
GO FDB DOCOL
 FDB MTBUF,MNTSCR,CR,CR
 FDB DOCMDARG,CR,CR
 FDB NOOP,NOOP,NOOP,NOOP,NOOP ; JNS -- filler to allow patch back in.
 FDB LIT,XMSGBS,AT,THREE,PLUS,DRZERO,LOAD  ; JNS  Disabled for now.
 FDB SEMIS
*
RAM FCB $C5
 FCC "FORT"
 FCB $80+'H
 FDB NOOP-7
RFORTH FDB DODOES,DOVOC,$81A0,TASK-7
 FDB 0
 FCC "(C) Bjarne B{ckstr|m 1984   "
 FCB $84
 FCC "TAS"
 FCB $80+'K
 FDB FORTH-8
RTASK FDB DOCOL,SEMIS
ERAM FCC "Bjarne B{ckstr|m "
*
 WORDM 3,'USE'
USE FDB DOCON,XUSE
*
 WORDM 4,'PREV'
PREV FDB DOCON,XPREV
*
 WORDM 4,'+BUF'
PBUF FDB DOCOL,BBUF
 FDB CLITER
 FCB 4
 FDB PLUS
 FDB PLUS,DUP,BBUF,PLUS,CLITER
 FCB 4
 FDB PLUS,LIMIT,GREAT,ZBRAN
 FDB PBUF2-*
 FDB DROP,FIRST
PBUF2 FDB DUP,PREV,AT,SUB,SEMIS
*
 WORDM 6,'UPDATE'
UPDATE FDB DOCOL,PREV,AT,AT,LIT,$8000,OR,PREV,AT,STORE,SEMIS
*
 WORDM 13,'EMPTY-BUFFERS'
MTBUF FDB DOCOL,FIRST,LIMIT,OVER,SUB,ERASE,SEMIS
*
 WORDM 6,'BUFFER'
BUFFER FDB DOCOL,USE,AT,DUP,TOR
BUFFR2 FDB PBUF,ZBRAN
 FDB BUFFR2-*
 FDB USE,STORE,R,AT,ZLESS,ZBRAN
 FDB BUFFR3-*
 FDB R,TWOP,R,AT,LIT,$7FFF,AND,ZERO,RW
BUFFR3 FDB R,STORE,R,PREV,STORE,FROMR,TWOP,SEMIS
*
 WORDM 5,'BLOCK'
BLOCK FDB DOCOL,OFSET,AT,PLUS,TOR,PREV,AT,DUP,AT,R,SUB
 FDB DUP,PLUS,ZBRAN
 FDB BLOCK5-*
BLOCK3 FDB PBUF,ZEQU,ZBRAN
 FDB BLOCK4-*
 FDB DROP,R,BUFFER,DUP,R,ONE,RW,TWO,SUB
BLOCK4 FDB DUP,AT,R,SUB,DUP,PLUS,ZEQU,ZBRAN
 FDB BLOCK3-*
 FDB DUP,PREV,STORE
BLOCK5 FDB FROMR,DROP,TWOP,SEMIS
*
 WORDM 5,'FLUSH'
FLUSH FDB DOCOL,LIMIT,FIRST,SUB,BBUF,CLITER
 FCB 4
 FDB PLUS,SLASH,ZERO,XDO
FLUSH1 FDB LIT
 FDB $7FFF
 FDB BUFFER,DROP
 FDB XLOOP
 FDB FLUSH1-*
 FDB SEMIS
*
 WORDM 6,'(LINE)'
PLINE FDB DOCOL,TOR,CLITER
 FCB $40
 FDB BBUF,SSMOD,FROMR,SCRBLK,PLUS,BLOCK,PLUS,CLITER
 FCB $40
 FDB SEMIS
*
 WORDM 5,'.LINE'
DLINE FDB DOCOL,PLINE,DTRAIL,TYPE,SEMIS
*
 WORDM 7,'MESSAGE'
MESS FDB DOCOL,WARN,AT,ZBRAN
 FDB MESS3-*
 FDB DDUP,ZBRAN
 FDB MESS4-*
 FDB LIT,XMSGBS,AT
 FDB OFSET,AT,TOR,ZERO,OFSET,STORE,DLINE,FROMR,OFSET,STORE
 FDB CR,BRAN
 FDB MESS4-*
MESS3 FDB PDOTQ
 FCB 4
 FCC "err "
 FDB CLITER
 FCB '#
 FDB BASE,AT,CLITER
 FCB 10
 FDB EQUAL,ZEQU,PLUS
 FDB EMIT,SPACE
 FDB DOT
MESS4 FDB SEMIS
*
 WORDM 4,'LOAD'
LOAD FDB DOCOL,BLK,AT,TOR,IN,AT,TOR,ZERO,IN,STORE,SCRBLK,BLK
 FDB STORE,INTERP,FROMR,IN,STORE,FROMR,BLK,STORE,SEMIS
*
 WORDM 3,'-->',IMMEDIATE
ARROW FDB DOCOL,QLOAD,ZERO,IN,STORE,BSCR,BLK,AT,OVER,MOD
 FDB SUB,BLK,PSTORE,SEMIS
*
 WORDM 1,"'",IMMEDIATE
TICK FDB DOCOL,DFIND,ZEQU,ZERO,QERR,DROP,LITER,SEMIS
*
 WORDM 6,'FORGET',NOIM
FORGET FDB DOCOL,CURENT,AT,CONTXT,AT,SUB,CLITER
 FCB $18
 FDB QERR,TICK,DUP,FENCE,AT,LESS,CLITER
 FCB $15
 FDB QERR,DUP,LIT,SINIT,AT,GREAT,CLITER
 FCB $15
 FDB QERR,DUP,NFA,DP,STORE,LFA,AT,CONTXT,AT,STORE,SEMIS
*
 WORDM 4,'BACK'
BACK FDB DOCOL,HERE,SUB,COMMA,SEMIS
*
 WORDM 5,'BEGIN',IMMEDIATE
BEGIN FDB DOCOL,QCOMP,HERE,ONE,SEMIS
*
 WORDM 5,'ENDIF',IMMEDIATE
ENDIF FDB DOCOL,QCOMP,TWO,QPAIRS,HERE,OVER,SUB,SWAP,STORE,SEMIS
*
 WORDM 4,'THEN',IMMEDIATE
THEN FDB DOCOL,ENDIF,SEMIS
*
 WORDM 2,'DO',IMMEDIATE
DO FDB DOCOL,COMPIL,XDO,HERE,THREE,SEMIS
*
 WORDM 4,'LOOP',IMMEDIATE
LOOP FDB DOCOL,THREE,QPAIRS,COMPIL,XLOOP,BACK,SEMIS
*
 WORDM 5,'+LOOP',IMMEDIATE
PLOOP FDB DOCOL,THREE,QPAIRS,COMPIL,XPLOOP,BACK,SEMIS
*
 WORDM 5,'UNTIL',IMMEDIATE
UNTIL FDB DOCOL,ONE,QPAIRS,COMPIL,ZBRAN,BACK,SEMIS
*
 WORDM 3,'END',IMMEDIATE
END FDB DOCOL,UNTIL,SEMIS
*
 WORDM 5,'AGAIN',IMMEDIATE
AGAIN FDB DOCOL,ONE,QPAIRS,COMPIL,BRAN,BACK,SEMIS
*
 WORDM 6,'REPEAT',IMMEDIATE
REPEAT FDB DOCOL,TOR,TOR,AGAIN,FROMR,FROMR,TWO,SUB,ENDIF,SEMIS
*
 WORDM 2,'IF',IMMEDIATE
IF FDB DOCOL,COMPIL,ZBRAN,HERE,ZERO,COMMA,TWO,SEMIS
*
 WORDM 4,'ELSE',IMMEDIATE
ELSE FDB DOCOL,TWO,QPAIRS,COMPIL,BRAN,HERE,ZERO,COMMA,SWAP
 FDB TWO,ENDIF,TWO,SEMIS
*
 WORDM 5,'WHILE',IMMEDIATE
WHILE FDB DOCOL,IF,TWOP,SEMIS
*
 WORDM 6,'SPACES'
SPACES FDB DOCOL,ZERO,MAX,DDUP,ZBRAN
 FDB SPACE3-*
 FDB ZERO,XDO
SPACE2 FDB SPACE,XLOOP
 FDB SPACE2-*
SPACE3 FDB SEMIS
*
 WORDM 2,'<#'
BDIGS FDB DOCOL,PAD,HLD,STORE,SEMIS
*
 WORDM 2,'#>'
EDIGS FDB DOCOL,DROP,DROP,HLD,AT,PAD,OVER,SUB,SEMIS
*
 WORDM 4,'SIGN'
SIGN FDB DOCOL,ROT,ZLESS,ZBRAN
 FDB SIGN2-*
 FDB CLITER
 FCB '-
 FDB HOLD
SIGN2 FDB SEMIS
*
 WORDM 1,'#'
DIG FDB DOCOL,BASE,AT,MSMOD,ROT,CLITER
 FCB 9
 FDB OVER,LESS,ZBRAN
 FDB DIG2-*
 FDB CLITER
 FCB 7
 FDB PLUS
DIG2 FDB CLITER
 FCB '0
 FDB PLUS,HOLD
 FDB SEMIS
*
 WORDM 2,'#S'
DIGS FDB DOCOL
DIGS2 FDB DIG,OVER,OVER,OR,ZEQU,ZBRAN
 FDB DIGS2-*
 FDB SEMIS
*
 WORDM 3,'D.R'
DDOTR FDB DOCOL,TOR,SWAP,OVER,DABS,BDIGS,DIGS,SIGN
 FDB EDIGS,FROMR,OVER,SUB,SPACES,TYPE,SEMIS
*
 WORDM 2,'.R'
DOTR FDB DOCOL,TOR,STOD,FROMR,DDOTR,SEMIS
*
 WORDM 2,'D.'
DDOT FDB DOCOL,ZERO,DDOTR,SPACE,SEMIS
*
 WORDM 1,'.'
DOT FDB DOCOL,STOD,DDOT,SEMIS
*
 WORDM 1,'?'
QUEST FDB DOCOL,AT,DOT,SEMIS
*
 WORDM 4,'LIST'
LIST FDB DOCOL,DEC,CR,DUP,SCR,STORE,PDOTQ
 FCB 6
 FCC "SCR # "
 FDB DOT
 FDB CLITER
 FCB 20
 FDB SPACES
 FDB DSYSSCR
 FDB CLITER
 FCB 16
 FDB ZERO,XDO
LIST2 FDB CR,I,THREE
 FDB DOTR,SPACE,I,SCR,AT,PLINE,TYPE,CLITER
 FCB $3C
 FDB EMIT,XLOOP
 FDB LIST2-*
 FDB CR,SEMIS
*
 WORDM 4,'DUMP'
DUMP FDB DOCOL,OVER,PLUS,SWAP,XDO
DUMP1 FDB I,CR,HEX,DOT,I,CLITER
 FCB 16
 FDB PLUS,I,XDO
DUMP2 FDB SPACE,I,CAT,TWO,DOTR,XLOOP
 FDB DUMP2-*
 FDB THREE,SPACES,I,CLITER
 FCB 16
 FDB PLUS,I,XDO

DUMP3 FDB I,CAT
 FDB LIT,$7F,AND
 fdb DUP,CLITER
 FCB $20
 FDB LESS,ZBRAN
 FDB DUMP31-*
 FDB DROP,CLITER
 FCB $5F
DUMP31 
 ; FDB LIT,$7F,AND
 FDB EMIT,XLOOP
 FDB DUMP3-*
 FDB CLITER
 FCB 16
 FDB XPLOOP
 FDB DUMP1-*
 FDB SEMIS
*
 WORDM 5,'VLIST'
VLIST FDB DOCOL,CLITER
 FCB $80
 FDB OUT,STORE,CONTXT,AT,AT
VLIST1 FDB OUT,AT,COLUMS,AT,CLITER
 FCB 16
 FDB SUB,GREAT,ZBRAN
 FDB VLIST2-*
 FDB CR ; ,ZERO,OUT,STORE REDUNDANT.
VLIST2 FDB DUP,IDDOT,SPACE,SPACE,PFA,LFA,AT,DUP,ZEQU,QTERM
 FDB OR,ZBRAN
 FDB VLIST1-*
 FDB DROP,SEMIS

*******************************************************************************
*
** DISK I/O WORDS **
*
*******************************************************************************
 WORDM 3,'#DR'
NUMDR FDB DOCON
 FDB 2                  ; the number of disk drives
*
 WORDM 8,'TRK/DISK'
TRKDSK FDB DOCON        ; tracks per disk
 FDB 40
*
 WORDM 7,'SEC/TRK'      ; sectors per track == block == sector
SECTRK FDB DOCON
 FDB 10
*
 WORDM 5,'B/BUF'
BBUF FDB DOCON
 FDB BUFSIZ
*
 WORDM 5,'B/SCR'
BSCR FDB DOCOL,LIT,1024,BBUF,SLASH,SEMIS
*
 WORDM 7,'SCR>BLK'
SCRBLK FDB DOCOL,BSCR,STAR,USEBLK,SLMOD,SECTRK,STAR
 FDB TRKDSK,STAR,PLUS,SEMIS
;***  allowing for the non integer # of screens per disk
 WORDM 6,'USEBLK' ; number of blocks per disk useable as screens
USEBLK FDB DOCOL,SECTRK,TRKDSK,STAR,BSCR,SLASH,BSCR,STAR,SEMIS
*
 WORDM 3,'DR0'
DRZERO FDB DOCOL,ZERO,OFSET,STORE
 FDB SEMIS
*
 WORDM 3,'DR1'
DRONE FDB DOCOL,ONE,DRIVE,SEMIS
*
 WORDM 5,'DRSIM'
DRSIM FDB DOCOL,NUMDR,DRIVE,SEMIS
*
 WORDM 5,'DRIVE'
DRIVE FDB DOCOL,SECTRK,TRKDSK,STAR,STAR,OFSET,STORE,SEMIS
*
 WORDM 2,'LO'
LO FDB DOCON
 FDB DSMBGN
*
 WORDM 2,'HI'
HI FDB DOCON
 FDB DSMEND
*
 WORDM 3,'R/W'
RW FDB DOCOL,SWAP               ; Buff@ R/WFlag Block#(tos)
 FDB DUP,ZLESS,ZEQU,ZBRAN       ; can't have block< 0
 FDB RWDE-*
 FDB SECTRK,TRKDSK,STAR,SLMOD   ; now have Buff@ R/WFlag Block# Drive#(tos)
 FDB DUP,NUMDR,GREAT,ZBRAN
 FDB RWD1-*
RWDE FDB CR,DOT,PDOTQ
 FCB 8
 FCC " Drive ?"
RWDE1 FDB LIT,$7FFF,PREV,AT,STORE,QUIT
RWD1 FDB DUP,NUMDR,EQUAL,ZBRAN
 FDB RWD2-*
 FDB DROP,TWOM,TWOM,DUP,ZLESS,ZBRAN
 FDB RWS1-*
RWRE FDB CR,DOT,PDOTQ
 FCB 8
 FCC " Range ?"
 FDB BRAN
 FDB RWDE1-*
RWS1 FDB BBUF,STAR,LO,PLUS,DUP,HI,BBUF,SUB,GREAT,ZEQU,ZBRAN
 FDB RWRE-*
RW4 FDB SWAP,ZBRAN
 FDB RW44-*
 FDB SWAP
RW44 FDB BBUF,CMOVE,SEMIS
; start with Buff@ R/WFlag Block# Drive#(tos)
RWD2 FDB TOR,SECTRK,SLMOD,SWAP,ONEP,SWAP,FROMR
 FDB DISKRW,SEMIS

*
 WORDM 6,'DISKRW'
; DISKRW FDB DOCOL,NOOP,SEMIS ; jns NOOP so I can patch in a different function.

; : DISKRW       ( BUF@ R/W SEC TRK DR# ... )
    ; DROP SEC/TRK * 1- SWAP ( BACK TO: BUF@ BLK# R/W )
    ; >R
    ; MPX9 SYSFCB 12 + !  ( BLK# )
;0008                  (                        mpx9.asm):00309 FCBSTR RMB 2 FILE START BLOCK #                 8
;000A                  (                        mpx9.asm):00310 FCBEND RMB 2 FILE END BLOCK #                   0a  10
;000C                  (                        mpx9.asm):00311 FCBCUR RMB 2 CURRENT RELATIVE BLOCK #           0c  12
;000E                  (                        mpx9.asm):00312 FCBPRV RMB 2 PREVIOUS RELATIVE BLOCK #          0e  14
;0010                  (                        mpx9.asm):00313 FCBNXT RMB 2 NEXT RELATIVE BLOCK #              10  16

        ; ( jns need to store block number +/- 1 (limited for 0 and max blk in file) in the next and prev fields )
        ; sysfcb 12 + @ dup if 1- then sysfcb 14 + ! ( prev link )
        ; sysfcb 12 + @ dup sysfcb 10 + @  sysfcb 8 + @ - 1+ = if drop 0 else 1+ then sysfcb 16 + !

; fcbend FCBSTR - 1+ === length

    ; SYSFCB 2+ ! ( Buf@ )
    ; SYSFCB R>
    ; IF    RD-BLK
    ; ELSE  WR-BLK
    ; THEN  RPTER  ;
  ; HEX

; MPX?M
; Cmd?F D000 DFFF 20
; Cmd?G
; MPX?S SCREEN.SC D000 DFFF
; MPX?
; FF77: 54             LSRB
; usim>P ../../mpx9/ramdisk.dsk 4000 9FFF
; SETSCR SCREEN.SC,16 HEX 0BBBB EMPTY-BUFFERS FLUSH 0 LIST

;JNS LBSR DSKRW0
;JNS LBRA NEXT
DISKRW 
    FDB    DOCOL
;;    FDB     SPAT,LIT,10,DUMP           ; jns debug
    FDB    DROP,SECTRK,STAR,PLUS,ONEM,SWAP
; ( BACK TO: BUF@ BLK# R/W )
;;    FDB     SPAT,LIT,10,DUMP           ; jns debug
; FDB     SYSFCB,LIT,$20,DUMP         ; jns debug
    FDB    TOR                             ; save r/w
    FDB    SYSFCB,LIT,12,PLUS,STORE    ; store current blk# in FCB
 FDB    SYSFCB,TWOP,STORE           ; store Buf@ in FCB
 FDB    SYSFCB,FROMR                ; setup FCB address on stack, and get r/w back
;;    FDB     LIT,$21,EMIT,DUP,DOT,SYSFCB,LIT,$20,DUMP ; JNS DEBUG
 FDB    ZBRAN
 FDB    DISKRW1-*
 FDB    RDBLK,BRAN
 FDB    DISKRW2-*
DISKRW1:
FOOOO SET 1
 IFDEF FOOOO
    FDB    SYSFCB,LIT,12,PLUS,AT    ; GET current blk# from FCB --- CURR#R
        ; ( jns need to store block number +/- 1 (limited for 0 and max blk in file) in the next and prev fields )

; --------------------------------------------------------------------------------
        ; dup dup if 1- then sysfcb 14 + ! ( prev link )
    FDB    DUP,DUP,ZBRAN                ; --- CURR#R  CURR#R
    FDB    DISKRW3A-*                   
    FDB    ONEM                         ; --- CURR#R  CURR#R-1
DISKRW3A
    FDB    SYSFCB,LIT,14,PLUS,STORE    ; save prev link. ---  CURR#R

; --------------------------------------------------------------------------------
        ; sysfcb 10 + @  sysfcb 8 + @ - 1+ = if drop 0 else 1+ then sysfcb 16 + !
    FDB    SYSFCB,LIT,10,PLUS,AT        ; ---  CURR#R  CURR#R  LAST#
    FDB    SYSFCB,LIT,8,PLUS,AT         ; ---  CURR#R  CURR#R  LAST# FIRST#
    FDB    MINUS,ONEP,SUB,ZEQU,ZBRAN    ; ---  CURR#R 
    FDB    DISKRW3B-*
    FDB    DROP,ZERO,BRAN               ; ---  ZERO
    FDB    DISKRW3C-*
DISKRW3B
    FDB    ONEP                         ; ---  CURR#R+1
DISKRW3C
    FDB    SYSFCB,LIT,16,PLUS,STORE ; save next link
 ENDC
 FDB    WRBLK
DISKRW2:
; FDB     SYSFCB,LIT,$20,DUMP         ; jns debug
 FDB    RPTER,SEMIS

*
; WORDM 3,'(_)'
;PDOS FDB DOCOL,R,COUNT,DUP,ONEP,FROMR,PLUS,TOR,GODOS,SEMIS
;*
;GODOS FDB *+2
; ; LBSR GODOS0          ---------------------------------- JNS JNS JNS
; LBRA NEXT
*

; NEXTNM SET *
 ; FCB $C1
 ; FCB $80+'_
 ; FDB LASTNM
; *
; LASTNM SET NEXTNM
; *
; DOSQ FDB DOCOL,CLITER
 ; FCB $22
 ; FDB STATE,AT,ZBRAN
 ; FDB DOS1-*
 ; FDB COMPIL,PDOS,WORD,HERE,CAT,ONEP,ALLOT,BRAN
 ; FDB DOS2-*
; DOS1 FDB WORD,HERE,COUNT,GODOS
; DOS2 FDB SEMIS
; *
 ; WORDM 3,'DOS'
; DOS FDB PDOSW
; FCBIN EQU USREND-$100-640
; FCBOUT EQU FCBIN+320
; *
 ; WORDM 6,'DISKIN'
; DISKIN FDB DOCON,FCBIN
; *
 ; WORDM 7,'DISKOUT'
; DISKOUT FDB DOCON,FCBOUT
; *
 ; WORDM 6,'REWIND'
; REWFD0 FDB *+2
 ; LBSR REWNDF
 ; LBRA NEXT
; *
 ; WORDM 6,'DELETE'
; DELTF0 FDB *+2
 ; LBSR DELETF
 ; LBRA NEXT
; *
 ; WORDM 4,'OPEN'
; OPENF0 FDB *+2
 ; LBSR OPENF
 ; LBRA NEXT
; *
 ; WORDM 4,'READ'
; READ FDB DOCOL,ONE,DISKIN,OPENF0,DISKIN,LIT,XFINA
 ; FDB STORE,SEMIS
; *
 ; WORDM 5,'WRITE'
; WRITE FDB DOCOL,ZERO,DISKOUT,OPENF0,DISKOUT,LIT,XFOUTA
 ; FDB STORE,SEMIS
; *
 ; WORDM 5,'CLOSE'
; CLOSF0 FDB *+2
 ; LBSR CLOSEF
 ; LBRA NEXT
; *
 ; WORDM 7,'CLOSEIN'
; CLOSIN FDB DOCOL,ZERO,LIT,XFINA,STORE
 ; FDB DISKIN,CLOSF0,SEMIS
; *
 ; WORDM 8,'CLOSEOUT'
; CLOSOT FDB DOCOL,ZERO,LIT,XFOUTA,STORE
 ; FDB DISKOUT,CLOSF0,SEMIS
; *

*******************************************************************************
*******************************************************************************
*******************************************************************************
** MPX/9 WORDS
*******************************************************************************
*******************************************************************************
*******************************************************************************

 WORDM 6,'(INIT)'
PINIT:              ; ( FCB@ FILENAME@ ... ERR# )
    FDB *+2
    PSHS    Y       ; save IP
    LDX     ,U++    ; X --> Filename
    LEAX    1,X     ; step over Forth length Byte
    LDY     ,U      ; Y --> FCB
    SWI3            ; go to MPX/9
    FCB     18      ; init fcb
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT

;: INIT        ( FCB INIT <FILENAME> )
;    BL WORD HERE 1+ (INIT) ;

 WORDM 4,'INIT'
INIT FDB DOCOL,BL,WORD,HERE
 FDB DUP,COUNT,ONEP,SWAP,ONEM,SWAP,SYSSCR,SWAP,CMOVE ; SAVE THE FILENAME.
 FDB PINIT,SEMIS

;CODE (RPTER)
;    ,U++ LDD,  0D MPX,  NEXT,

 WORDM 7,'(RPTER)'
PRPTER:              ; ( ERR# ...  )
    FDB *+2
    LDD     ,U++    ; X --> Filename
    SWI3            ; go to MPX/9
    FCB     13      ; report error
    LBRA    NEXT

;: RPTER       ( PRINT MPX/9 ERROR MESSAGE; N ... )
;    -DUP  IF  (RPTER)  ." ERROR .............." CR QUIT  THEN ;
    
 WORDM 5,'RPTER'
RPTER FDB DOCOL,DDUP,ZBRAN
    FDB RPTER1-*
    FDB CR,PRPTER
    FDB CR,QUIT
RPTER1
    FDB SEMIS

; CODE OPEN    ( 1=R,2=W,3=RW BUFFER@ FCB@ ... ERR# )
    ; SAVEIP,
    ; ,U++ LDY,  ,U++ LDX,  1 ,U LDA,  13 MPX,
    ; CLRA,  0,U STD,
    ; RESTOREIP,  NEXT,

 WORDM 4,'OPEN'
OPEN:
    FDB *+2
    PSHS    Y       ; save IP
    LDY     ,U++    ; Y --> FCB
    LDX     ,U++    ; X --> BUFFER
    LDA     1,U     ; A == R/W
    SWI3            ; go to MPX/9
    FCB     19      ; OPEN
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT

; CODE CLOSE   ( FCB ... ERROR# )
    ; SAVEIP,
    ; 0,U LDY,  014 MPX,  CLRA,  0,U STD,
    ; RESTOREIP, NEXT,

 WORDM 5,'CLOSE'
CLOSE:
    FDB *+2
    PSHS    Y       ; save IP
    LDY     ,U      ; Y --> FCB
    SWI3            ; go to MPX/9
    FCB     20      ; CLOSE
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT

; CODE DELETE  ( FCB ... ERROR# )
    ; SAVEIP,
    ; 0,U LDY,  020 MPX,  CLRA,  0,U STD,
    ; RESTOREIP, NEXT,

 WORDM 6,'DELETE'
DELETE:
    FDB *+2
    PSHS    Y       ; save IP
    LDY     ,U      ; Y --> FCB
    SWI3            ; go to MPX/9
    FCB     32      ; DELETE
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT


; CODE R-SEC  ( READ SECTOR; FCB@ ... ERR# )
    ; SAVEIP,
    ; .Y. PULU,  23 MPX,  CLRA,
    ; RESTOREIP,
    ; .D. PSHU,  NEXT,

 WORDM 6,'RD-BLK'
RDBLK:
    FDB *+2
    PSHS    Y       ; save IP
    LDY     ,U      ; Y --> FCB
    SWI3            ; go to MPX/9
    FCB     23      ; READ-BLOCK
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT

; CODE W-SEC  ( WRITE SECTOR; FCB@ ... ERR# )
    ; SAVEIP,
    ; .Y. PULU,  24 MPX,  CLRA,
    ; RESTOREIP,
    ; .D. PSHU,  NEXT,

 WORDM 6,'WR-BLK'
WRBLK:
    FDB *+2
    PSHS    Y       ; save IP
    LDY     ,U      ; Y --> FCB
    SWI3            ; go to MPX/9
    FCB     24      ; WRITE-BLOCK
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT



; CODE MPX       ( RETURN TO MPX/9 )
        ; 8 MPX, NEXT,

 WORDM 3,'MPX'
MPX:
    FDB *+2
    SWI3            ; go to MPX/9
    FCB     8       ; return to mpx/9
    CLRA
    STD     ,U      ; store error code (a:b)
    LBRA    NEXT

; CODE (MPX)     ( COMMAND@ n ... ERR# )
    ; SAVEIP,
    ; ,U++ LDX,  0,U LDX,  0C MPX,
    ; CLRA,  0,U STD,
    ; RESTOREIP,  NEXT,

 WORDM 5,'(MPX)'
PMPX:
    FDB *+2
    PSHS    Y       ; save IP
    LEAU    2,U     ; drop the N parameter
    LDX     ,U      ; X --> command
    SWI3            ; go to MPX/9
    FCB     12      ; PROCMD
    CLRA
    STD     ,U      ; store error code (a:b)
    PULS    Y       ; restore IP
    LBRA    NEXT


; CODE (+CR)     ( ADD A CR TO A STRING; STR@ ... STR@ )
   ; 0,U LDX,  0,X INC,  0,X LDB,  ABX,  $D ## LDA,  0,X STA,
   ; NEXT,

 WORDM 5,'(+CR)'
PPCR:
    FDB *+2
    LDX     ,U      ; X --> string
    INC     ,X      ; increment count at start of string
    LDB     ,X      ; get count
    ABX             ; x --> end of string
    LDA     #$D    
    STA     ,X
    LBRA    NEXT

; : MPX"
    ; MPX9 HERE  2+  [COMPILE] "  (+CR)  STATE  @
    ; IF
      ; 1 ALLOT COMPILE (MPX)
    ; ELSE
     ; (MPX)
    ; THEN
    ; DROP ;  IMMEDIATE


 WORDM 6,'(MPX")'
PMPXQ FDB DOCOL,R,COUNT,DUP,ONEP,FROMR,PLUS,TOR,PMPX,RPTER,SEMIS ; AT PMPX: ADDR COUNT -- 

 WORDM 4,'MPX"',IMMEDIATE
MPXQ FDB DOCOL,CLITER
 FCB $22
 FDB STATE,AT,ZBRAN
 FDB MPXQ1-*
 FDB COMPIL,PMPXQ,WORD,HERE,PPCR,CAT,ONEP,ALLOT,BRAN
 FDB MPXQ2-*
MPXQ1 FDB WORD,HERE,PPCR,COUNT,PMPX,RPTER ; AT PMPX: ADDR COUNT -- 
MPXQ2 FDB SEMIS

;: :BUFFER                  ( CREATE A BUFFER; n :BUFFER <NAME> )
;    <BUILDS HERE OVER ERASE ALLOT
;    DOES> ;

 WORDM 7,':BUFFER'
CBUFFER FDB DOCOL,BUILDS,HERE,OVER,ERASE,ALLOT
DOBUFFER FDB DOES,SEMIS

;: :FCB                ( CREATE FILE CONTROL BLOCK; :FCB <NAME> )
;    $20 :BUFFER ;

 WORDM 4,':FCB'
CFCB FDB DOCOL,LIT,$20,CBUFFER,SEMIS

 WORDM 6,'SYSFCB' ; screen file fcb
SYSFCB FDB DODOES,DOBUFFER+2
    ZMB  $20

 WORDM 6,'SYSSCR' ; screen file name
SYSSCR FDB DODOES,DOBUFFER+2
    ZMB  $20

 WORDM 7,'SYSBUFF' ; screen file buffer; also used by fload
SYSBUFF FDB DODOES,DOBUFFER+2
    ZMB  $100

; 13 : SETSCR         ( SETSCR <FILENAME> )                    
; 14     SYSFCB  INIT  RPTER  3  SYSBUFF  SYSFCB  OPEN  RPTER  ;            
; 12 : MNTSCR                                                         
; 13     SYSFCB  " SCRNFILE.SC " (INIT) RPTER                          
; 14     3  SYSBUFF  SYSFCB  OPEN  RPTER  ;         

; JNS add a buffer to store the screen file name in, commands to display it, and put it in the output of list.

 WORDM 7,'OPENSCR'  ; ( OPENSCR; ... )
OPENSCR FDB DOCOL,THREE,SYSBUFF,SYSFCB,OPEN,RPTER,SEMIS

 WORDM 6,'SETSCR'   ; ( SETSCR <FILENAME>; ... )
SETSCR FDB DOCOL,SYSFCB,INIT,RPTER,OPENSCR,SEMIS

 WORDM 6,'MNTSCR'   ; ( MNTSCR; ... )
MNTSCR FDB DOCOL,SYSFCB,PQUOTE
 FCB X-*
 FCC 'X/SCRNFILE.SC '
X SET *-1
 FDB DUP,LIT,$F02A,CAT,LIT,$30,PLUS,SWAP,ONEP,CSTORE ; PATCH ABOVE FILENAME TO BE SAME DRIVE AS TFORTH09
 FDB DUP,COUNT,ONEP,SWAP,ONEM,SWAP,SYSSCR,SWAP,CMOVE ; SAVE THE FILENAME.
 FDB PINIT,RPTER,OPENSCR,SEMIS

 WORDM 7,'.SYSSCR'   ; ( .SYSSCR --> OUTPUT CURRENT SCREENFILE NAME; ... )
DSYSSCR FDB DOCOL,SYSSCR,COUNT,TYPE,SEMIS


; Screen # 7
; 00 ( LOADFILE SUPPORT - RD-LINE                      JNS 03/15/84 )
; 01                                                                 
; 02 CODE  RD-LINE  ( lineBUFFER@  FCB@  ...  ERRORCODE )                
; 03     Y. PSHS,                      ( save ip )                   
; 04     Y. X. PULU,    X. Y. EXG,     ( save ip, load x,y )         
; 05     BEGIN,                                                      
; 06         21 MPX,                   ( read character )            
; 07         EQ IF,                    ( if no mpx/9 error )         
; 08             ,X+  STA,             ( put char in buffer )        
; 09             13 # CMPA,            ( char=cr ? )                 
; 10             EQ IF,  ,-X CLR,  TSTA,  ELSE, CLRA,  THEN,         
; 11             THEN,                                               
; 12         NE UNTIL,                 ( char=cr or mpx/9 error)     
; 13     ,X+ CLR,  0,X CLR,            ( append too nulls to buffer )
; 14     CLRA,    Y. PULS,             ( restore ip in Y )           
; 15     PUSHD JMP,    ;S              ( push error code and return )

 WORDM 7,'RD-LINE'
RD_LINE:
    FDB *+2
    PSHS    Y       ; SAVE IP

    LDY     ,U++    ; Y --> FCB
    LDX     ,U      ; X --> LINEBUFFER

        ; FCB 2 BREAK TO DEBUGGER.

RD_LINE1:
    SWI3            ; GO TO MPX/9
    FCB     21      ; READ CHAR A:CHARACTER READ, B:ERROR CODE CC: PER B

    BNE     RD_LINE2 ; GO IF ERROR
    STA     ,X+
    CMPA    #$0D    ; CR?
    BEQ     RD_LINE3
    CMPA    #$0A    ; LF?
    BNE     RD_LINE1
RD_LINE3
    leax    ,-x     ; back up on char

RD_LINE2
    CLR     ,X+     ; two nulls at end of line.
    CLR     ,X

    CLRA
    STD     ,U      ; STORE ERROR CODE (A:B)

    PULS    Y       ; RESTORE IP
    LBRA    NEXT

; ( Screen 6 )                                        
; $10 CONSTANT ERR_EF
; : LOADFILE    (   LOADFILE <FILENAME>   )        
;     FLOADFCB BL WORD HERE (INIT) RPTER                      
;     1 ( read ) SYSBUFF FLOADFCB OPEN RPTER  
;     BLK @ >R  IN @ >R  0 BLK !                                 
;     BEGIN                                                      
;         TIB @ FLOADFCB RD-LINE   
;         ERR_EF = 
;         TIB @ C@ 0=  AND 0= 
;         WHILE 0 IN ! INTERPRET REPEAT                   
;     R> IN ! R> BLK !                                    
;     BLK @ 0= IF 0 TIB @ ! 0 IN ! THEN ;       ;S                
;  ( MNTSCR 6 LOAD LOADFILE JNS.4T )     

 WORDM 8,'FLOADFCB'
FLOADFCB FDB DODOES,DOBUFFER+2
    ZMB  $20

 WORDM 5,'FLOAD'
FLOAD FDB DOCOL
    FDB FLOADFCB,BL,WORD,HERE,PINIT,RPTER
    FDB ONE,SYSBUFF,FLOADFCB,OPEN,RPTER
    FDB BLK,AT,TOR,IN,AT,TOR,ZERO,BLK,STORE
FLOAD1:
    FDB TIB,AT,FLOADFCB,RD_LINE
    FDB LIT,$10,EQUAL
    FDB TIB,AT,CAT,ZEQU,AND,ZEQU,ZBRAN
    FDB FLOAD2-*
    FDB ZERO,IN,STORE,INTERP,BRAN 
    FDB FLOAD1-*
FLOAD2:
    FDB FROMR,IN,STORE,FROMR,BLK,STORE
    FDB BLK,AT,ZEQU,ZBRAN
    FDB FLOADX-*
    FDB ZERO,TIB,AT,STORE,ZERO,IN,STORE
FLOADX:
    FDB SEMIS
 ENDC

; : MLOAD  IN @ >R  TIB @ >R  0 IN !  TIB !  INTERPRET  R> TIB !  R> IN !  QUIT ; 
 WORDM 5,'MLOAD' ; ( cmd-addr MLOAD;  cmd@ ... )
MLOAD FDB DOCOL

    ; FDB IN,AT,DOT ; JNS DEBUG
    ; FDB TIB,AT,DOT ; JNS DEBUG
    ; FDB BLK,AT,DOT ; JNS DEBUG


    FDB IN,AT,TOR
    FDB TIB,AT,TOR
    FDB ZERO,IN,STORE
    FDB ZERO,BLK,STORE
    FDB TIB,STORE ; arg from stack.
    FDB INTERP

    ; FDB IN,AT,DOT ; JNS DEBUG
    ; FDB TIB,AT,DOT ; JNS DEBUG
    ; FDB BLK,AT,DOT ; JNS DEBUG

   ; FDB PDOTQ
   ; FCB 3
   ; FCC "***"


    FDB FROMR,TIB,STORE
    FDB FROMR,IN,STORE
;    FDB QUIT
    FDB SEMIS


; : MLOAD  IN @ >R  TIB @ >R  0 IN !  TIB !  INTERPRET  R> TIB !  R> IN !  ( QUIT) ; 

 WORDM 7,'MEMBOOT' ; ( ... )
MEMBOOT FDB DOCOL,LIT,MBTEXT,AT,LIT,$4D42,MINUS,ZEQU,ZBRAN
        FDB MEMBOOT2-*
        FDB LIT,MBTEXT,TWOP,MLOAD
MEMBOOT2:
        FDB SEMIS


; : DOCMDARG CMDARG @ DUP 40 + SWAP DO I C@ DUP EMIT $D = IF 0 I C! LEAVE THEN LOOP CMDARG @ MLOAD ;
 WORDM 8,'DOCMDARG' ; ( ... )
DOCMDARG FDB DOCOL
        FDB CMDARG
        FDB AT
        FDB DUP
        FDB LIT
        FDB 40
        FDB PLUS
        FDB SWAP
        FDB XDO
DOCMDARG1 FDB I
        FDB CAT
        ; FDB DUP
        ; FDB EMIT
        FDB LIT
        FDB $D
        FDB EQUAL
        FDB ZBRAN
        FDB DOCMDARG2-*
        FDB ZERO
        FDB I
        FDB CSTORE
        FDB LEAVE
DOCMDARG2 FDB XLOOP
        FDB DOCMDARG1-*
        FDB CMDARG
        FDB AT
        FDB MLOAD
        FDB SEMIS

; : AA CMDARG @ DUP 40 + SWAP DO I C@ DUP EMIT $D = IF 0 I C! LEAVE THEN LOOP 
;  CMDARG @ MLOAD ;  OK
;   OK
;   OK
; 579  OK456 + .
;   OK
;   OK
; CR AA CR 
; 123 456 + .(SYSDIR)SY579 
;  OK
;   OK
; ' AA 30 DUMP 
; 20FC  08EC 06B9 069C 01F9 0040 042F 068B 0273   _l_9___y_@_/___s
; 210C  0282 06C5 069C 00B2 01F9 000D 094C 021D   ___E___2_y___L__
; 211C  000A 077D 0282 06E1 063D 023A FFE4 08EC   ___}___a_=_:d_l OK

; : U. 0 D. ;
; : AA CMDARG @ DUP 40 + SWAP DO I C@ DUP EMIT $D = IF 0 I C! LEAVE THEN LOOP CMDARG @ MLOAD ;
; 2/TFORTH09 123 456 + .
; CMDARG @ 20 DUMP 
; : DOCMDARG CMDARG @ DUP 40 + SWAP DO I C@ $D = IF 0 I C! LEAVE THEN LOOP CMDARG @ MLOAD ;
; CMDARG @ DUP 40 + SWAP 0 D. 0 D. 
; DOCMDARG

; CMDARG @ 20 DUMP 
; CMDARG @  MLOAD

; ( SUPPOR FOR M/FLOAD TO HANDEL NEWLINE CHARACTERS. )
; NEXTNM SET *
;  FCB $C1
;  FCB $8A
;  FDB LASTNM
; LASTNM SET NEXTNM
; RETRN FDB DOCOL,SEMIS

; : VOCS VOC-LINK @ BEGIN DUP WHILE DUP 6 - NFA ID. @ REPEAT DROP ;
 WORDM 4,'VOCS' ; ( VOCS; ... )
VOCS FDB DOCOL,VOCLIN,AT
VOCS1
    FDB DUP,ZBRAN
    FDB VOCS2-*
    FDB DUP,LIT,6,SUB,NFA,IDDOT,AT,BRAN
    FDB VOCS1-*
VOCS2
    FDB DROP,SEMIS

 WORDM 4,'NOOP'
NOOP FDB NEXT
*
; FDOSBG EQU *
; FBGNIO SET $1A50
 ; ORG FBGNIO
; *
; FBYTSC SET $17BB
; FFINA SET $2028
; FFOUTA SET $202A
; FACIA SET $2018
*
PEMIT LBRA PPEMIT
PKEY LBRA PPKEY
PQTER LBRA PPQTER
*
PMON LBRA RESMON
; PDOSW JMP [DOSWRM,PCR]
; GODOS0 LBRA GODOSI
; DSKRW0 LBRA DSKRWI
; *
; OPENF LBRA OPENFI
; *
; CLOSEF LBRA CLOSFI
; REWNDF LBRA REWNDI
; DELETF LBRA DELETI
; *
 ; RMB 9
; *
; NXTMON EQU $F802
; *
; DOSFCB FDB $C840
; DOSIBF FDB $C080
; DOSSDN FDB $CC0B
; DOSWDN FDB $CC0C
; DOSBPT FDB $CC14
; DOSDET FDB $CC20
; DOSWRM FDB $CD03
; DOSGFL FDB $CD2D
; DOSEXT FDB $CD33
; DOSRER FDB $CD3F
; DOSCMD FDB $CD4B
; DOSFCL FDB $D403
; DOSFMS FDB $D406
; *
 ; RMB 6
; *
;JNS+
; Console Input
PPKEY   LDX     CIDCB
        LDB     #ReadFn
        JSR     REQIO
        RTS

; Console Output
PPEMIT  LDX     CODCB
        ANDA    #$7F
        LDB     #WritFn
        JSR     REQIO
        RTS

; Console Status
PPQTER  LDX     CIDCB
        LDB     #StatFn
        JSR     REQIO
        ANDA    #1
        BNE     PPKEY
        RTS
;jns-

; PPEMIT PSHS B,X
 ; TST FFOUTA
 ; BEQ PEMIT0
 ; LDX FFOUTA
; FLAIO LBSR FMSCAL
 ; BRA PEMIT2
; PEMIT0 LDX FACIA
; PEMIT1 LDB ,X
 ; BITB #2
 ; BEQ PEMIT1
 ; STA 1,X
; PEMIT2 PULS B,X
 ; RTS
; *
; PPKEY PSHS B,X
 ; TST FFINA
 ; BEQ PKEY0
 ; LDX FFINA
 ; BRA FLAIO

; PKEY0 LDX FACIA
; PKEY2 LDB ,X
 ; ASRB
 ; BCC PKEY2
 ; LDA 1,X
 ; ANDA #$7F
 ; BRA PEMIT2

; PPQTER PSHS X
 ; LDX FACIA
 ; LDA ,X
 ; ASRA
 ; BCS PQTER2
; *
 ; CLRA
 ; BRA PQTER3

; PQTER2 LDA 1,X
 ; CMPA #$1B
 ; BNE PQTER3

; PQTER8 LDA ,X
 ; ASRA
 ; BCC PQTER8
 ; LDA 1,X
 ; CMPA #$1B
 ; BNE PQTER3
 ; CLRA

; PQTER3 PULS X
; PQTER4 RTS

; GODOSI PULU D,X
 ; PSHS U,Y
 ; LDU DOSIBF
 ; STU [DOSBPT,PCR]
 ; TFR D,Y
; GODOS1 LDA ,X+
 ; STA ,U+
 ; LEAY -1,Y
 ; BNE GODOS1
 ; LDA #$D
 ; STA ,U
 ; JSR [DOSCMD,PCR]
 ; PULS U,Y
 ; RTS

; DRSEL EQU $DE0C
; DRREAD EQU $DE00
; DRWRIT EQU $DE03
; DRVERF EQU $DE06

; NUMTRY FCB 0

; DSKRWI LDX DOSFCB
 ; LDD ,U++
 ; STB 3,X
 ; JSR DRSEL
 ; LDA #10
 ; STA NUMTRY

; DSKRC1 LDA 1,U
 ; LDB 3,U
 ; TST 5,U
 ; BEQ DSKRWW
 ; LDX 6,U

; DSKRW1 JSR DRREAD
 ; BEQ DSKRTS
 ; DEC NUMTRY
 ; BNE DSKRC1
 ; LDA #'R
 ; BRA DSKRWE

; DSKRWW LDX 6,U
; DSKRWL JSR DRWRIT
 ; JSR DRVERF
 ; BEQ DSKRTS
 ; DEC NUMTRY
 ; BNE DSKRC1
 ; LDA #'W
 ; BRA DSKRWE

; DSKRTS LEAU 8,U
 ; RTS

; DSKRWE LBSR PPEMIT
 ; LEAU 8,U
 ; LBRA 3

; RWDSE0 JSR [DOSRER,PCR]
 ; JMP 3,PCR

; CHKERR BNE CHKER0
 ; RTS

; CHKER0 LDB 1,X
 ; CMPB #8
 ; BNE RWDSE0
 ; CLR FFINA
 ; CLR FFINA+1
 ; LDA #$D
 ; RTS

; OPENFI PSHS Y
 ; LDY 4,U
; * file name
 ; LEAY 1,Y
 ; LDX DOSIBF,PCR
 ; LDB -1,Y
; OPNL1 BEQ OPNL2
 ; LDA ,Y+
 ; STA ,X+
 ; DECB
 ; BRA OPNL1

; OPNL2 LDA #$D
 ; STA ,X
 ; LDX DOSIBF,PCR
 ; STX [DOSBPT,PCR]
 ; LDX 0,U
 ; LDA [DOSWDN,PCR]
 ; STA 3,X
 ; JSR [DOSGFL,PCR]
; *
 ; LDA #1
 ; JSR [DOSEXT,PCR]
 ; LDA 3,U
 ; LEAU 6,U
 ; PULS Y
 ; BNE FMSCL1
 ; LDA #2
 ; BRA FMSCL1

; FMSCLL LDX ,U++
; FMSCL1 STA 0,X
; FMSCAL JSR [DOSFMS,PCR]
 ; BSR CHKERR
 ; RTS

; CLOSFI LDA #4
 ; BRA FMSCLL

; REWNDI LDA #5
 ; BRA FMSCLL

; DELETI LDA #$C
 ; BRA FMSCLL

;jns+
RESMON JMP [MonEntv]
 ; JSR [DOSFCL,PCR]
 ; JMP [NXTMON,PCR]
;jns-

; FDOSIN EQU *-1
;*

 FILL 0,USRBGN-*

 ; ORG USRBGN     ; variables
N zmb 10        ; used as scratch
UP zmb 2        ; the pointyer to the base of current user's USER table (for multi-tasking)
*
* This system is shown for one user , but additional ones
* may be added by allocating additional user tables and
* words for switching the pointer between them. 
* Alternatively , with SWTP SBUG dynamic memory assignment, it would
* be possible to have a memory magenent procedure in KERNAL which
* switches various USER 4k blocks in and out of this low space.
*
* Some of the next stuff is initialized during COLD and WARM starts.
* Names correspond to FORTH words of similar (no X) name.
*
UORIG zmb 6
;* INIT ON COLD START
XFENCE zmb 2    ; fence for FORGET
XDP zmb 2       ; dictionary pointer
XVOCL zmb 2     ; vocabulary linking
XACIA zmb 2     ; address of acia
XDELAY zmb 2    ; carriage return delay couut (# of nulls)
XCOLUM zmb 2    ; carriage width
XBKSP zmb 1     ; backspace character
XBKSPE zmb 1    ; backspace echo
XLINDL zmb 1    ; linedelete chcracter
XLINDE zmb 1    ; linedelete echo
;* INIT BELOW ON COLD OR WARM START
XSPZER zmb 2    ; initial top of data stack for this user
XTIB zmb 2      ; start of terminal input buffer
XRZERO zmb 2    ; initial top of return stack
XFINA zmb 2     ; address of input file FCB
XFOUTA zmb 2    ; address of output file PCB
XWIDTH zmb 2    ; name field width
XMSGBS zmb 2    ; Base Screen number for messages and GO
XWARN zmb 2     ; warning message node ( 0 = no disk )
;* END OF INITIALIZED PARAMETERS
XBLK FDB 0
XIN FDB 0
XOUT FDB 2
XSCR FDB 0
XOFSET FDB 0
XCONT FDB TASK-7
XCURR FDB TASK-7
XSTATE FDB 0
XBASE FDB 10
XDPL FDB 2
XFLD FDB 0
XCSP FDB 0
XRNUM FDB 0
XHLD FDB 0
; IOSTAT FDB 0
XCMDARG FDB 0   ; pointer to command line args
XIBASE FDB 0   ; input base conversion


*
 FCB $C5 immediate
 FCS 'FORTH'
 FDB NOOP-7
FORTH FDB DODOES,DOVOC,$81A0,TASKAA
 FDB 0
 FCC "(C) Bjarne B{ckstr|m 1984   "
*
TASKAA FCB $84
 FCS 'TASK'
 FDB FORTH-8
*
TASK FDB DOCOL,SEMIS
REND EQU *
*

 ZMB $200 ; PADD OUT SO DP & HERE USAGE DOES NOT OVERRITE THE BOOT FILES BELOW.
          ; at least until it is safe for do so.
MBTEXT EQU *
 FCC "MB"
* jns INCLUDE BOOT FILES HERE TO LOAD ON STARTUP.
 INCLUDEBIN memboot.tmp
 fcb 0,0,0,0

 END PRGBGN
